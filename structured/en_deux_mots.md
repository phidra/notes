(ces notes correspondent à une sorte de glossaire tech, initialement [sur mon blog](https://phidra.github.io/blog/) ; mais je préfère les gérer comme markdown public)

----

L'objectif de cette page est de "documenter" toutes les notions que je croise, liées de près ou de loin à mon métier.

Je mets des guillemets autour de "documenter", car il s'agit ici d'être concis : juste expliquer la notion en quelques mots, et éventuellement un ou deux pointeurs pour en apprendre plus.

D'autres ressources sur internet ont la même vocation, et sont de bien meilleure qualité que cette page : elle a surtout de l'intérêt pour MOI, vu que c'est les notions que j'ai croisées MOI que je reporte ici, et que je les décris avec MES mots à moi, en y joignant les références que JE trouve pertinentes.

- **Abstract Data Type** (ADT) : spécification d'une structure de données et de son comportement, sans préciser son implémentation ; [lien wikipedia](https://fr.wikipedia.org/wiki/Type_abstrait)
- **Argument-Dependent Lookup** (ADL) : si `f` est une free-floating function, l'appel `f(a, b)` va être résolu par un compilo C++ :
    -  en recherchant une fonction `f` qui accepte un `A` et un `B` dans le namespace courant
    -  en recherchant une fonction `f` qui accepte un `A` et un `B` dans le namespace de `A`
    -  en recherchant une fonction `f` qui accepte un `A` et un `B` dans le namespace de `B`
- **C3 linearization** : algo permettant de trouver la MRO à partir d'une hiérarchie d'héritage multiple donnée en entrée ([lien wikipedia](https://en.wikipedia.org/wiki/C3_linearization))
- **Edge Computing** : les calculs sont faits, et les décisions sont prises directement sur le dispositif (données traitées au plus proche de leur source : IoT, sonde curiosity, etc.), par opposition aux cas où le dispositif déporte ses calculs+décision sur un serveur externe, centralisé ([lien](https://blog.octo.com/quest-ce-que-ledge-computing/))
- **Goal-Directed Approaches (routing)** : _direct the search towards the target t by preferring edges that shorten the distance to t and by excluding edges that cannot possibly belong to a shortest path to t — such decisions are usually made by relying on preprocessed data._ cf. [le survey de 2016 sur le calcul d'itinéraire](https://arxiv.org/abs/1504.05140)
- **H-tree** : structure fractale recouvrant une surface, présentant la propriété intéressante que tous les noeuds terminaux sont à la même distance de la racine. Utilisé pour [distribuer uniformément le signal d'horloge](https://www.techspot.com/article/1830-how-cpus-are-designed-and-built-part-2/) dans un CPU ([lien wikipedia](https://en.wikipedia.org/wiki/H_tree))
- **Hierarchical Approaches (routing)** : _try to exploit the hierarchical structure of the given network. In a preprocessing step, a hierarchy is extracted, which can be used to accelerate all subsequent queries._ cf. [le survey de 2016 sur le calcul d'itinéraire](https://arxiv.org/abs/1504.05140)
- **Immediately Invoked Function Expression** (IIFE) : idiome de plusieurs langages consistant à définir une lambda et à l'appeler sur une même ligne sans en garder une référence.
- **LINQ** : abstraction propre à C# autour de langages de requêtes de données, proche du SQL. D'après [cet article](https://blog.scottlogic.com/2021/04/22/losing-the-fear.html), c'est la caractéristique propre à C# (comme le sont les destructeurs pour le C++) ; [doc microsoft](https://docs.microsoft.com/fr-fr/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries) et [lien wikipedia](https://fr.wikipedia.org/wiki/Language_Integrated_Query)
- **Loi de Conway** : les designs tendent à refléter l'organisation de la communication au sein de l'entreprise (rien à voir avec l'inventeur du jeu de la vie) ; [lien octo](https://blog.octo.com/reussir-une-conway-inversee-compte-rendu-du-talk-de-romain-vailleux-a-la-duck-conf-2021/), [lien wikipedia](https://fr.wikipedia.org/wiki/Loi_de_Conway)
- **Multiversion concurrency control** (MVCC) : une forme de concurrency-control où chaque user voit un snapshot des données à une version particulière ; [lien wikipedia](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)
- **Semipredicate problem** : situation où une fonction qui ne retourne qu'un élément (en situation nominale : son résultat) veut également pouvoir renvoyer une erreur, et on se retrouve donc embêté à vouloir renvoyer deux types d'information dans une seule valeur de retour ([lien wikipedia](https://en.wikipedia.org/wiki/Semipredicate_problem))
- **Write-ahead log** (WAL) : technique utilisée par les databases pour permettre l'atomicité et la durabilité, en écrivant d'abord les requêtes sur disque avant de les transférer dans la DB ; [lien wikipedia](https://en.wikipedia.org/wiki/Write-ahead_logging)
- **bag of functions** : style qui va plutôt à l'encontre de l'OOP, consistant à utiliser un jeu de fonctions indépendantes (travaillant sur un même type d'objet) plutôt qu'une classe ; p.ex. `open(file, modes) / close(file)` plutôt que `file.open(modes) / file.close()` ; [lien](https://leontrolski.github.io/mostly-pointless.html)
- **compressed sparse row graph** : format de stockage d'un graphe (que je connais sous le nom d'adjacency array), où on packe tous les edges du graphe dans un seul tableau, regroupés par tail-node, et où un deuxième tableau contient pour chaque node le pointeur vers ses out-edges dans le premier tableau ; [lien boost](https://www.boost.org/doc/libs/1_61_0/libs/graph/doc/compressed_sparse_row.html)
- **concurrency control** : _concurrency control ensures that correct results for concurrent operations are generated, while getting those results as quickly as possible_ ; [lien wikipedia](https://en.wikipedia.org/wiki/Concurrency_control)
- **consistent hashing** : algorithme de hashing permettant de ne pas jeter tout les hashs à la poubelle lorsqu'on ajoute/enlève une instance (les hashs invalidés par cette redistribution sont limités à une fraction) : [lien octo](https://blog.octo.com/consistent-hashing-ou-l%E2%80%99art-de-distribuer-les-donnees/)
- **copy-and-swap** : idiome C++ implémentant l'opérateur d'assignation `operator=`, consistant à construire une copie temporaire de l'objet, et à se swapper avec cette copie temporaire ; [lien](https://mropert.github.io/2019/01/07/copy_swap_20_years/)
- **data race vs. race condition** : race condition = terme le plus générique, où la bonne marche du programme n'est pas garantie car elle se repose sur le fait que des évènements (e.g. l'ordre d'exécution des threads) se seront déroulés dans le bon ordre ; data race = un cas particulier de race condition, où un thread essaye de lire une donnée pendant qu'un autre thread l'écrit ; [lien](https://www.avanderlee.com/swift/race-condition-vs-data-race/)
- **duck-typing vs. templates** : dans les faits, pas beaucoup de différences, hormis que le templating se fait à la compilation alors que le duck-typing examine plutôt les types au runtime
- **dynamic binding** : la résolution de la fonction ou méthode réellement exécutée est faite tardivement, au runtime ; [lien wikipedia](https://en.wikipedia.org/wiki/Late_binding)
- **green threads** : quand un language runtime ou une VM gère ses propres threads plutôt que de se reposer sur le threading proposé par l'OS ; [lien wikipedia](https://en.wikipedia.org/wiki/Green_threads)
- **hyperparamètre** : paramètre "résumant", i.e. settant la valeur d'autres paramètres plus précis (le terme a également un autre sens pour l'apprentissage : [lien wikipedia](https://fr.wikipedia.org/wiki/Hyperparam%C3%A8tre))
- **loi de demeter** : _Only talk to your immediate friends ; The fundamental notion is that a given object should assume as little as possible about the structure or properties of anything else (including its subcomponents), in accordance with the principle of "information hiding"._ ([lien wikipedia](https://en.wikipedia.org/wiki/Law_of_Demeter))
- **mark-and-sweep garbage-collector** : une stratégie possible pour les garbage-collector. Prérequis = on sait itérer sur tous les objets racine (e.g. les objets dont le storage n'est pas sur le heap). Mark = on parcourt tous les objets racines, et on marque toute la mémoire qui est atteignable depuis les objets racine. Sweep = puis, on parcourt tous les objets, et on détruit tous ceux qui n'ont pas été marqués. De nos jours, les GC efficaces sont générationnels ; [lien microsoft](https://docs.microsoft.com/en-us/archive/blogs/abhinaba/back-to-basics-mark-and-sweep-garbage-collection)
- **multiple dispatch** : dispatch qui va un cran plus loin que les fonctions virtuelles (qui dispatchent en fonction d'un unique critère = le type de l'objet sur lequel on a appelé la méthode), qui permettent de dispatcher selon d'autres critères, p.ex. d'autres arguments que `this`. [lien wikipedia](https://en.wikipedia.org/wiki/Multiple_dispatch)
- **non-blocking / wait-free / lock-free** : trois notions proches mais avec de subtiles différences qui tournent autour du fait de pouvoir faire du multithreading sans bloquer, p.ex. sans mutex ; [lien wikipedia](https://en.wikipedia.org/wiki/Non-blocking_algorithm).
- **objectifs SMART** : critères définissant un bon objectif = _Specific Measurable Ambitious Realistic Time-bound_ ; [lien wikipedia](https://fr.wikipedia.org/wiki/Objectifs_et_indicateurs_SMART)
- **open-addressing** : l'une des implémentations possibles des résolutions de conflits dans les hashmaps (son grand rival étant le _separate chaining_) ; les collisions sont simplement placées dans une autre cellule du tableau que celle correspondant à leur hash, de façon suffisamment déterministe pour pouvoir les retrouver plus tard.
- **overload set** : ensemble de fonctions _pouvant_ être matché par un appel template ; [lien1 (excellent !)](https://preshing.com/20210315/how-cpp-resolves-a-function-call/) ; [lien abseil](https://abseil.io/tips/148) ; [lien cppreference](https://en.cppreference.com/w/cpp/language/overload_resolution)
- **portail d'amorçage** : outil automatisant le bootstrap de projet ; [lien octo](https://blog.octo.com/les-portails-damorcage-projet-tiennent-ils-leurs-promesses/)
- **reference counting garbage-collector** : une autre stratégie possible pour les GC. Chaque objet compte les références qui peuvent l'atteindre. Quand ce compteur tombe à zéro, l'objet est immédiatement détruit. C'est ce qu'utilise python, couplé à un autre GC pour les cycles : [lien](https://devguide.python.org/internals/garbage-collector/index.html)
- **separate-chaining** : l'une des implémentations possibles des résolutions de conflits dans les hashmaps (son grand rival étant l' _open-addressing_) ; chaque cellule du tableau contient un link-list de tous les éléments ayant le même hash.
- **single compilation unit / unity build** (SCU) : idiome C/C++ consistant à fusionner plusieurs fichiers source au sein d'une même translation-unit, pouvant parfois accélérer les builds, ou permettre des optimisations du même genre que la LTO. [lien wikipedia](https://en.wikipedia.org/wiki/Single_Compilation_Unit)
- **string interning** : ce que fait python avec les strings = on n'en a qu'une instance immutable, et plusieurs références peuvent pointer vers elle (lien avec le pattern flyweight) ; [lien](https://arpitbhayani.me/blogs/string-interning)
- **structural subtyping vs. nominal subtyping** : structural subtyping = le duck-typing de python ou les templates C++ : si un type X a ce qu'il faut pour se comporter comme un type A, alors X est un sous-type de A ; nominal subtyping = les fonctions virtuelles : pour qu'un type X soit un sous-type de A, il faut qu'il en hérite explicitement.
- **top-down / bottom-up** : _top-down_ = partir du général, pour en arriver au particulier / _bottom-up_ = commencer par le particulier, et en déduire la construction d'une vision générale. Exemple de la lecture d'un livre de mathématique : top-down commence par lire le sommaire pour voir la structure du livre, avant de le lire intégralement ; bottom-up commence par lire le livre en entier, puis prends du recul et subdivise le contenu en différentes catégories pour reconstruire le sommaire. [lien lemonde](https://www.lemonde.fr/blog/internetactu/2015/10/09/comment-apprenons-nous-le-paradoxe-de-la-creativite/)
- **type erasure** : _erase the type of an object while still holding a “handle” to it and being able to make use of it_ ; [lien1](https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/), [lien2](https://akrzemi1.wordpress.com/2013/12/11/type-erasure-part-iii/), et [lien boost](https://www.boost.org/doc/libs/1_75_0/doc/html/boost_typeerasure.html) qui présente ça comme un mélange entre les templates (structural subtyping) et les fonctions virtuelles (nominal subtyping).
- **type traits** : propriétés sur un type qui ne fait pas partie du type lui-même, mais qui lui est adjoint de façon externe. Le trait définit des propriétés génériques sur les types, et on peut le template-spécialiser pour définir des propriétés sur un type en particulier, sans modifier le type lui-même ; [lien Patrice ROY](https://h-deb.clg.qc.ca/Sujets/Divers--cplusplus/Traits.html)
- **unbounded array** : semble être ce que font les `std::vector` = ne réallouer que quand on dépasse la capacité ([lien StackOverflow](https://stackoverflow.com/questions/21510201/what-is-an-unbounded-array)).
- **undefined behaviour** : le programme est mal codé, il a donc le droit de faire n'importe quoi — _nasal demons_ ; [lien cppreference](https://en.cppreference.com/w/cpp/language/ub), [lien wikipedia](https://en.wikipedia.org/wiki/Undefined_behavior)
- **upstream / downstream** : upstream = vers l'auteur originel / downstream = en s'éloignant de l'auteur original ; liens wikipedia [upstream](https://en.wikipedia.org/wiki/Upstream_(software_development)) et [downstream](https://en.wikipedia.org/wiki/Downstream_(software_development))
- **value semantic / reference semantic** : deux façons de concevoir une donnée ; l'opposition reference-semantic vs. value-semantic semble être regroupée sous le terme "sémantique d'accès". Certains langages (e.g. java, python) ont une sémantique de référence, et p.ex. les paramètres des fonctions sont systématiquement des références, d'autres langages (e.g. C++) ont une sémantique de valeur, les paramètres des fonctions sont des valeurs. [lien isopcpp](https://isocpp.org/wiki/faq/value-vs-ref-semantics) ; [lien Patrice ROY](https://h-deb.clg.qc.ca/Sujets/Divers--cplusplus/Sainte-Trinite.html)
- **vendoring** : intégrer une copie de ses dépendances à son package (plutôt que d'exprimer la dépendance, qui doit être résolue de façon externe) : _bundling dependencies rather than getting them from other packages_ ; [lien lwn](https://lwn.net/SubscriberLink/842319/8adb13e08d0302bd/)
- **virtual table = vtable** : moyen d'implémenter le dynamic dispatch, chaque instance possède une table de pointeurs vers les fonctions virtuelles (et ces pointeurs pointent vers la bonne version de la méthode à appeler) ; [lien wikipedia](https://en.wikipedia.org/wiki/Virtual_method_table)
- **worse is better** : _software quality does not necessarily increase with functionality: there is a point where less functionality ("worse") is a preferable option ("better")_ ; [lien wikipedia](https://en.wikipedia.org/wiki/Worse_is_better)

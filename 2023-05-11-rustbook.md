# The Rust Programming Language

- **url** = https://doc.rust-lang.org/book/
- **type** = livre de référence sur le langage
- **auteur** = Steve Klabnik and Carol Nichols, with contributions from the Rust Community
- **date de publication** = N/A (le contenu est mis à jour régulièrement)
- **source** = [doc officielle rust](https://doc.rust-lang.org/)
- **tags** = language>rust ; topic>language ; level>beginner

Livre chaudement recommandé par Vivien.

Je n'annote pas tout exhaustivement, je me contente de quelques pointeurs, mots ou concepts clés, citations, et commentaires persos. Je ne prends pas de notes de synthèse (e.g. sur les différentes commandes cargo possibles), je me contente d'annoter au fil des chapitres.


* [The Rust Programming Language](#the-rust-programming-language)
   * [Installation](#installation)
      * [Utilisation avec neovim](#utilisation-avec-neovim)
   * [Chapitre 1 = Getting Started](#chapitre-1--getting-started)
   * [Chapitre 2 = Programming a Guessing Game](#chapitre-2--programming-a-guessing-game)
   * [Chapitre 3 = Common Programming Concepts](#chapitre-3--common-programming-concepts)
   * [Chapitre 4 = Understanding Ownership](#chapitre-4--understanding-ownership)
      * [Chapitre 4.1 = What Is Ownership?](#chapitre-41--what-is-ownership)
      * [Chapitre 4.2 = References and Borrowing](#chapitre-42--references-and-borrowing)
      * [Chapitre 4.3 = The Slice Type](#chapitre-43--the-slice-type)
   * [Chapitre 5 = Using Structs to Structure Related Data](#chapitre-5--using-structs-to-structure-related-data)
      * [Chapitre 5.1 = Defining and Instantiating Structs](#chapitre-51--defining-and-instantiating-structs)
      * [Chapitre 5.2 = An Example Program Using Structs](#chapitre-52--an-example-program-using-structs)
      * [Chapitre 5.3 = Method Syntax](#chapitre-53--method-syntax)
   * [Chapitre 6 = Enums and Pattern Matching](#chapitre-6--enums-and-pattern-matching)
      * [The match Control Flow Construct](#the-match-control-flow-construct)
      * [Concise Control Flow with if let](#concise-control-flow-with-if-let)
   * [Chapitre 7 = Managing Growing Projects with Packages, Crates, and Modules](#chapitre-7--managing-growing-projects-with-packages-crates-and-modules)
   * [Chapitre 8 = Common Collections](#chapitre-8--common-collections)
   * [Chapitre 9 = Error Handling](#chapitre-9--error-handling)
   * [Chapitre 10 = Generic Types, Traits, and Lifetimes](#chapitre-10--generic-types-traits-and-lifetimes)
      * [Chapitre 10.1 = Generic Data Types](#chapitre-101--generic-data-types)
      * [Chapitre 10.2 = Traits: Defining Shared Behavior](#chapitre-102--traits-defining-shared-behavior)
      * [Validating References with Lifetimes](#validating-references-with-lifetimes)
         * [quel problème résout-on grâce aux lifetimes ?](#quel-problème-résout-on-grâce-aux-lifetimes-)
   * [Chapitre 11 = Testing](#chapitre-11--testing)
      * [11.1. How to Write Tests](#111-how-to-write-tests)
      * [11.2 Controlling How Tests Are Run](#112-controlling-how-tests-are-run)
      * [11.3 Test Organization](#113-test-organization)
   * [Chapitre 12 = An I/O Project: Building a Command Line Program](#chapitre-12--an-io-project-building-a-command-line-program)
   * [Chapitre 13 = Functional Language Features: Iterators and Closures](#chapitre-13--functional-language-features-iterators-and-closures)
      * [13.1. Closures: Anonymous Functions that Capture Their Environment](#131-closures-anonymous-functions-that-capture-their-environment)
      * [13.2. Processing a Series of Items with Iterators](#132-processing-a-series-of-items-with-iterators)
      * [13.3. Improving Our I/O Project](#133-improving-our-io-project)
      * [13.4. Comparing Performance: Loops vs. Iterators](#134-comparing-performance-loops-vs-iterators)
   * [14. More about Cargo and Crates.io](#14-more-about-cargo-and-cratesio)
      * [14.3. Cargo Workspaces](#143-cargo-workspaces)
   * [Chapitre 15 = Smart Pointers](#chapitre-15--smart-pointers)
      * [15.1. Using Box to Point to Data on the Heap](#151-using-box-to-point-to-data-on-the-heap)
         * [Using a Box to Store Data on the Heap](#using-a-box-to-store-data-on-the-heap)
         * [Enabling Recursive Types with Boxes](#enabling-recursive-types-with-boxes)
         * [Computing the Size of a Non-Recursive Type](#computing-the-size-of-a-non-recursive-type)
         * [Using Box to Get a Recursive Type with a Known Size](#using-box-to-get-a-recursive-type-with-a-known-size)
      * [15.2. Treating Smart Pointers Like Regular References with the Deref Trait](#152-treating-smart-pointers-like-regular-references-with-the-deref-trait)
      * [15.3. Running Code on Cleanup with the Drop Trait](#153-running-code-on-cleanup-with-the-drop-trait)
      * [15.4. Rc, the Reference Counted Smart Pointer](#154-rc-the-reference-counted-smart-pointer)
      * [15.5. RefCell and the Interior Mutability Pattern](#155-refcell-and-the-interior-mutability-pattern)
      * [15.6. Reference Cycles Can Leak Memory](#156-reference-cycles-can-leak-memory)
   * [Chapitre 16 = Fearless Concurrency](#chapitre-16--fearless-concurrency)
      * [16.1. Using Threads to Run Code Simultaneously](#161-using-threads-to-run-code-simultaneously)
      * [16.2. Using Message Passing to Transfer Data Between Threads](#162-using-message-passing-to-transfer-data-between-threads)
      * [16.3. Shared-State Concurrency](#163-shared-state-concurrency)
      * [16.4. Extensible Concurrency with the Sync and Send Traits](#164-extensible-concurrency-with-the-sync-and-send-traits)
   * [Chapitre 17 = Object Oriented Programming Features of Rust](#chapitre-17--object-oriented-programming-features-of-rust)
      * [17.1. Characteristics of Object-Oriented Languages](#171-characteristics-of-object-oriented-languages)
      * [17.2. Using Trait Objects That Allow for Values of Different Types](#172-using-trait-objects-that-allow-for-values-of-different-types)
      * [17.3. Implementing an Object-Oriented Design Pattern](#173-implementing-an-object-oriented-design-pattern)
   * [18. Patterns and Matching](#18-patterns-and-matching)
      * [18.1. All the Places Patterns Can Be Used](#181-all-the-places-patterns-can-be-used)
      * [18.2. Refutability: Whether a Pattern Might Fail to Match](#182-refutability-whether-a-pattern-might-fail-to-match)
      * [18.3. Pattern Syntax](#183-pattern-syntax)

## Installation

J'ai suivi la recommandation officielle :

```sh
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# [...]

rustc --version
# rustc 1.69.0 (84c898d65 2023-04-16)
```

J'ai conservé les chemins par défaut, ils sont indiqués dans la sortie de l'installation :

<details>
  <summary>Cliquer pour voir l'output</summary>

```
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust
programming language, and its package manager, Cargo.

Rustup metadata and toolchains will be installed into the Rustup
home directory, located at:

  /home/myself/.rustup

This can be modified with the RUSTUP_HOME environment variable.

The Cargo home directory is located at:

  /home/myself/.cargo

This can be modified with the CARGO_HOME environment variable.

The cargo, rustc, rustup and other commands will be added to
Cargo's bin directory, located at:

  /home/myself/.cargo/bin

This path will then be added to your PATH environment variable by
modifying the profile files located at:

  /home/myself/.profile
  /home/myself/.bashrc
  /home/myself/.zshenv

You can uninstall at any time with rustup self uninstall and
these changes will be reverted.

Current installation options:


   default host triple: x86_64-unknown-linux-gnu
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes
```

</details>

### Utilisation avec neovim

J'utilise [rust-tools](https://github.com/simrat39/rust-tools.nvim#setup).

Dans le `.vimrc` (

```lua
require('rust-tools').setup{
   on_attach = on_attach,
   flags = lsp_flags,
}
```

Attention que le `require` est un poil différent des autres lspconfig, ce qui est rappelé explicitement dans [la doc](https://github.com/simrat39/rust-tools.nvim#setup) :

> This plugin automatically sets up nvim-lspconfig for rust_analyzer for you, so don't do that manually, as it causes conflicts.

(on trouve aussi le setup de rust-analyzer, légèrement différent, [ici](https://rust-analyzer.github.io/manual.html#nvim-lsp)).

Chez moi, après une fresh installation de rust avec rustup, `rust-analyzer` n'est pas utilisable :

- sous neovim, quand je tape `:LspLog` :
    ```
    [START][2023-05-12 11:48:00] LSP logging initiated
    [START][2023-05-12 11:48:45] LSP logging initiated
    [ERROR][2023-05-12 11:48:46] .../vim/lsp/rpc.lua:420▶   "rpc"▶  "rust-analyzer"▶"stderr"▶   "error: 'rust-analyzer' is not installed for the toolchain 'stable-x86_64-unknown-linux-gnu'\n"
    ```
- et effectivement, dans un terminal, le binaire `rust-analyzer` a beau exister, il n'est pas utilisable :
    ```
    rust-analyzer --version
    # error: 'rust-analyzer' is not installed for the toolchain 'stable-x86_64-unknown-linux-gnu'
    ```

Du coup, je suis [la doc](https://rust-analyzer.github.io/manual.html#rust-analyzer-language-server-binary) de `rust-analyzer` pour l'installer :

```sh
curl -L https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - > ~/.local/bin/rust-analyzer
chmod +x ~/.local/bin/rust-analyzer
```

Mais comme j'ai maintenant deux versions concurrentes de `rust-analyzer`, il faut que je désactive celle qui ne marche pas → ça fonctionne :

```sh
mv ~/.cargo/bin/rust-analyzer ~/.cargo/bin/REMOVED_rust-analyzer

rust-analyzer --version
# rust-analyzer 0.3.1506-standalone
```

Note : on dirait que `rust-analyzer` nécessite un projet cargo pour fonctionner, et qu'il ne peut pas compiler un code-source standalone :

```
[ERROR][2023-05-12 11:58:39] .../vim/lsp/rpc.lua:420▶   "rpc"▶  "rust-analyzer"▶"stderr"▶   '[ERROR rust_analyzer::config] failed to find any projects in [AbsPathBuf("/path/to/my/projects")]\n'
[ERROR][2023-05-12 11:58:39] .../vim/lsp/rpc.lua:420▶   "rpc"▶  "rust-analyzer"▶"stderr"▶   "[ERROR rust_analyzer::main_loop] FetchWorkspaceError:\nrust-analyzer failed to discover workspace\n"
```

## Chapitre 1 = Getting Started

https://doc.rust-lang.org/book/ch01-00-getting-started.html

`rustup` = tool pour installer et maintenir rust.

Il faut un linker, voire un C compiler.

`rustc` = le compilateur rust.

Dans l'Appendix D :

- `rustfmt` = formatter
- `rustfix` = fixeur d'erreurs
- `rust-analyzer` = LSP

Macro = "fonction" suffixée par `!`

`cargo` = à la fois _build-system_ et _package-manager_ :

 ```
cargo new
cargo build (--release)
cargo run
cargo check
```

Le build par défaut est en mode `debug` (donc l'exécutable buildé va dans `target/debug/`)

`cargo.lock` = versions pinnées des dépendances du projet.

Un `crate` (qui se traduit en "caisse") est un package.

## Chapitre 2 = Programming a Guessing Game

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html

`associated functions` d'un type donné.

Syntaxe : préfixe `&` = référence

Les références sont immutables par défaut, il faut `&mut myref` si on veut des références mutables.

`Result` est un enum qui vaut soit `Ok` soit `Error`

`expect()` gère les deus valeurs possibles de `Result` :

- si on reçoit un `Ok`, il renvoie la valeur du `Ok`
- si on reçoit une `Error`, il crashe

Si le code-source ne traite que le `Ok`, le programme compile quand même, mais avec un warning.

Quand on utilise la macro `println!`, les strings peuvent interpréter des templates (comme les f-strings).

> Rust doesn’t yet include random number functionality in its standard library. However, the Rust team does provide a rand crate with said functionality.

https://crates.io = le registre officiel des crates, un genre d'équivalent de pypi.


Quand on précise des versions dans `Cargo.toml`, même si la version `0.8.5` précisée veut en fait dire `^0.8.5` (et que donc la version `O.8.6` sera préférée à la `0.8.5` quand elle sortira), une fois que `Cargo.lock` a été généré avec la `0.8.5`, le projet n'utilisera plus que cette version, même si la `0.8.6` sort après coup. (et je suppose qu'il faut supprimer `Cargo.lock`, ou utiliser une commande (EDIT : `cargo update`) pour le mettre à jour pour passer explicitement à la `0.8.6`)

> When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the Cargo.lock file. When you build your project in the future, Cargo will see that the Cargo.lock file exists and will use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at 0.8.5 until you explicitly upgrade, thanks to the Cargo.lock file. Because the Cargo.lock file is important for reproducible builds, it’s often checked into source control with the rest of the code in your project.
>
> When you do want to update a crate, Cargo provides the command update, which will ignore the Cargo.lock file and figure out all the latest versions that fit your specifications in Cargo.toml.

Sur les traits :

> The Rng trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods.

L'expression `start..=end` est une range-expression qui inclut `start` et `end`.

> running the cargo doc --open command will build documentation provided by all your dependencies locally and open it in your browser

Un exemple de pattern-matching (pour comparer le nombre entré au nombre recherché) est donné :

> A match expression is made up of arms. An arm consists of a pattern to match against, and the code that should be run if the value given to match fits that arm’s pattern. (...)
>
> Patterns and the match construct are powerful Rust features: they let you express a variety of situations your code might encounter and they make sure you handle them all.

On voit que le langage a été pensé par des devs :

> Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess, for example. 

Quand on convertit une string en int avec `parse()`, c'est l'un des cas où il faut préciser explicitement le type (par exemple pour savoir dans quel type d'entier placer la string parsée).

Au lieu de `expect()` un `Result`, on peut faire un `match` pour traiter les deux cas :

```rs
let guess: u32 = match guess.trim().parse() {
   Ok(num) => num,
   Err(_) => continue,
};
```

----

Mes notes en refaisant le guessing game moi-même :

- il y a deux types de strings, des literal et des string objects
- `expect()` ne semble pas autoriser un string object, uniquement un string literal
- avec les rust-tools dans neovim, il y a un truc SUPER cool, c'est qu'il indique les types de chaque ligne

## Chapitre 3 = Common Programming Concepts

https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html

Variables immutables par défaut (pas encore clair si c'est la référence qui est constante, ou l'objet).

`let` vs `let mut`

`const` = constante connue au compile time (donc plus fort qu'une variable non-mutable)

Répéter `let` avec le même nom de variable pour shadower une variable par une autre.

4 primary scalar types = `int` + `float` + `bool` + `char`

Le flottant par défaut est `f64`, soit l'équivalent d'un `double`.

`isize` / `usize`= équivalents de `size_t` = de quoi indexer un conteneur, architecture-dépendent car 64 bit ou 32 bit :

> The primary situation in which you’d use isize or usize is when indexing some sort of collection.

Comment rust réagit en cas d'overflow au runtime ?

- En mode debug, il panic
- En mode release, il complémente à deux

(note que l'overflow peut dépendre d'un I/O utilisateur, e.g. si on additionne deux entiers que l'utilisateur a entrés → on peut ne pas le connaître au compile-time)

Les `char` sont des points de code unicode (et je suppose que les strings sont des tableaux de `char` ; EDIT : non, a priori, ce sont des bytestrings encodées en UTF-8).

`tuple` + unpacking (de son vrai nom : _destructuring_)

Syntaxe : indexer un tuple se fait avec un `.` : `my_tuple.2`

Bizarrement, le tuple vide a un nom = `unit`.

Array = même type + longueur fixe (c'est l'équivalent des arrays C) vs. vector (le distinguo semble similaire à celui du C++).

> Arrays are useful when you want your data allocated on the stack rather than the heap (...) or when you want to ensure you always have a fixed number of elements.

Indexer un array se fait comme habituellement = avec des crochets : `my_array[2]`

L'indexing d'un array peut échouer au runtime (mais au lieu d'aller bêtement accéder à la mémoire invalide, et de segfault dans le meilleur des cas, rust va dynamiquement checker la bound et panic si besoin). C'est au runtime que le check a lieu, et comme l'index peut être entré en I/O au runtime, on ne peut pas le savoir au compile-time :

> When you attempt to access an element using indexing, Rust will check that the index you’ve specified is less than the array length. If the index is greater than or equal to the length, Rust will panic. This check has to happen at runtime, especially in this case, because the compiler can’t possibly know what value a user will enter when they run the code later.
>
> This is an example of Rust’s memory safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this.

Syntaxe : keyword pour définir des fonctions : `fn`

Les expressions ont l'air plus importantes en rust que dans d'autres langages :

> - Statements are instructions that perform some action and do not return a value.
> - Expressions evaluate to a resultant value. Let’s look at some examples.

Si une fonction se termine par une expression (sans `;` final ! Sinon ce n'est plus une expression mais un statement), alors la fonction retourne la valeur de cette expression.

Syntaxe : un grand bloc entre accolades est une expression.

> You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.

Les fonctions qui ne retournent rien (soit explicitement avec un `return` vide, soit implicitement via leur dernière expression) renvoient alors `unit` = le tuple vide.

Syntaxe : les `if` sont sans parenthèses.

Les `if` n'acceptent que des bools (pas de cast implicite d'une expression en bool, ce qui est une bonne chose IMO).

La syntaxe de l'opérateur ternaire est plutôt lisible : `let number = if condition { 5 } else { 6 };`

Syntaxe : `loop` pour remplacer `while true` (et elle peut retourner une expression !).

On peut labelliser les loops pour choisir à laquelle s'applique un `break` ou `continue`.

La boucle `for` est comme en python : elle boucle sur les éléments d'un itérable (again : une bonne chose).

## Chapitre 4 = Understanding Ownership

https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html

> [Ownership] enables Rust to make memory safety guarantees without needing a garbage collector

### Chapitre 4.1 = What Is Ownership?

https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html

Les règles d'ownership sont vérifiées au compile-time, pas au runtime (donc pas de ralentissement au runtime).

> Because ownership is a new concept for many programmers, it does take some time to get used to.

^ sans doute le célèbre combat contre le borrow-checker

Le résumé de stack vs. heap est très bien écrit ; morceaux choisis :

> Both the stack and the heap are parts of memory available to your code to use at runtime, but they are structured in different ways.
>
> The stack stores values in the order it gets them and removes the values in the opposite order. [...] All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.
>
> The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. [...] Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.
>
> Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation. Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. 
>
> [...] knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does

^ Cette dernière phrase est cruciale : l'unique objectif de la gestion de la mémoire (que ce soit par garbage-collection, par gestion manuelle ou par l'approche retenue par rust = l'ownership) est de gérer les données du heap (notamment d'éviter les use-after-free et les double-free), c'est le problème qu'on essaye de résoudre. (plus bas, c'est ce qui explique qu'il n'y a pas de notion d'ownership pour `let y = x;` avec des entiers, qui n'ont aucune donnée sur le heap, mais qu'il y en a pour les strings).

Le principe de l'ownership est proche des `unique_ptr` (que je me plais à voir comme "manipuler des heap-allocated data comme si elles étaient sur la stack") :

> - Each value in Rust has an owner.
> - There can only be one owner at a time.
> - When the owner goes out of scope, the value will be dropped.

La page prend l'exemple de la class `String` pour les explications :

> This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time.

Avec les string literal, la variable pointe vers une valeur hardcodée dans le programme (NdM : sans doute dans le segment RO du process ; EDIT = confirmé un peu plus bas = _In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable_).

Création d'un String object à partir d'un literal :

```rs
let s = String::from("hello");
```

En deux mots, rust a du RAII built-in dans le langage (`drop()` du trait `Drop` est appelée automatiquement lorsqu'une variable arrive en fin de vie) ; so far so good, les choses deviennent compliquées quand plusieurs personnes veulent accéder à la même zone mémoire :

> the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we’ve allocated on the heap

[Ce chapitre](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move) donne des éléments de réponse à une question que je me posais = est-ce que les variables sont des références ou des objets. Dit autrement, si je fais `let y = x`, ai-je deux OBJETS (y qui est une copie de x) ou ai-je deux RÉFÉRENCES vers le même objet ? Dans le cas des entiers, il y a copie ; dans le cas des strings, il y a move (i.e. les deux strings ont utilisé vers le même buffer). Du coup, j'en déduis que le comportement est similaire au C++ = copie, avec le twist lié à l'ownership.

L'exemple est bien parlant :

```rs
let s1 = String::from("hello");
let s2 = s1;
```

La copie a invalidé la référence vers la string copiée (la deuxième string a pris l'ownership du buffer : le buffer a été _moved_).

> Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance.

^ il faut `x.clone()` explicitement si on veut deep-copy.

Pour les types qui ne gèrent pas de données sur le heap, la copie peut être deep sans surcoût :

> there’s no difference between deep and shallow copying here

Pour créer ses types custom qui sont copiables sans surcoût, on les annote avec le trait `Copy` (incompatible avec le trait `Drop`).

> Rust has a special annotation called the Copy trait that we can place on types that are stored on the stack, as integers are (...). If a type implements the Copy trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable.

Le point déroutant = le passage d'arguments aux fonctions move (ou copy, selon le type) tout comme l'assignation dans notre exemple précédent :

> Passing a variable to a function will move or copy, just as assignment does

Dit autrement, à moins que le type soit trivialement copiable, passer une variable à une fonction est suffisant pour la détruire (vu qu'elle est move dans la fonction, et sera détruite quand on sortira du scope de la fonction).

Le comportement fonctionne aussi dans l'autre sens = lorsqu'une fonction `return` une variable, elle est moved ! En résumé, sans précaution particulière, les fonctions prennent et rendent l'ownership.

(dans les exemples qui sont donnés, beaucoup de variables se retrouvent donc dans des états similaires au `moved-from` du C++)

### Chapitre 4.2 = References and Borrowing

https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html

> Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference

Syntaxe : on préfixe les références par `&`, aussi bien pour les variables que pour les types :

```rs
let s1 = String::from("hello");
let len = calculate_length(&s1);

// (...)
fn calculate_length(s: &String) -> usize {
```

Les références sont non-owning (quand la référence arrive en fin de scope, on ne libère aucune donnée sur le heap).

> We call the action of creating a reference **borrowing**.

Les références sont immutables par défaut, il faut `mut` une référence qu'on veut pouvoir muter. S'il existe une référence mutable en vie, aucune autre référence (peu importe qu'elle soit mutable ou immutable !) ne peut exister :

> Mutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value.

L'objectif est d'éviter des data-race, où un thread mute une variable pendant qu'un autre thread la lit.

De façon un peu contre-intuitive, le scope des références ne dure pas jusqu'à la fin du bloc, mais uniquement jusqu'à la ligne de sa dernière utilisation ; on peut donc créer une référence mutable juste après la dernière utilisation d'une référence immutable, elles ne se marcheront pas sur les pieds.

Il est impossible de créer une dangling-reference en rust.

Le résumé :

> At any given time, you can have either one mutable reference or any number of immutable references.

### Chapitre 4.3 = The Slice Type

https://doc.rust-lang.org/book/ch04-03-slices.html

NDM : "j'ai l'ownership de cet objet", ça veut dire "c'est moi qui suis responsable de libérer la mémoire de cet objet (et je le ferai automatiquement quand j'arriverai en fin de vie)"

Syntaxe : `let myslice = &s[4..8];`

Les slices semblent être des équivalents des `std::string_view` = un couple "pointeur vers un item d'un array + nombre d'éléments".

Un slice est une forme de référence → le truc cool par rapport aux string views : comme le slice est une référence et que rust empêche d'avoir une dangling référence, le slice est intrinsèquement couplé à la string = on ne peut pas invalider un slice par erreur. Au final, l'exemple qu'ils donnent en utilisant les slices est une bonne illustration des erreurs que le borrow-checker permet d'empêcher.

Bizarrement, le type d'un slice est `&str`.


NDM : au sujet de l'ownership, tout tient au fait que les références mutables sont exclusives, i.e. si on a une référence mutable, on ne peut pas avoir d'autre référence (mutable ou immutable) en vie en même temps. Or, un slice est une référence immutable et l'action de clear la string nécessite une référence mutable (pour muter la string) → on ne pourra donc pas clear une String tant qu'il existe un slice (qui est une référence immutable) dessus, ce qui empêche donc d'invalider par erreur un slice existant. Plus généralement, une bonne vision est de considérer que pour muter un objet (y compris via une de ses méthodes) on utilise une référence mutable dessus, ce qui interdit l'existence par ailleurs d'une référence, même immutable.

Note : si une fonction attend un slice (`&str`) en argument, elle acceptera certes des slices, mais également des `String` objects (considérés comme un slice "complet"), ou même des string literals (qui sont des slices du binaire du programme).

Les slices ne sont pas spécifiques aux strings : `&[i32]` est le type d'un slice vers un tableau d'entiers.

> The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.

## Chapitre 5 = Using Structs to Structure Related Data

https://doc.rust-lang.org/book/ch05-00-structs.html


### Chapitre 5.1 = Defining and Instantiating Structs

https://doc.rust-lang.org/book/ch05-01-defining-structs.html

La syntaxe pour instancier une struct est un poil bizarre (mais avec l'habitude, je m'y ferai sans souci).

Il y a une syntaxe pour instancier une struct à partir d'une autre (ce qui laisse donc cette dernière dans un état invalide = moved-from ; à moins que les champs clonés soient trivialement copiables) en ne modifiant que certains fields.

`tuple structs` = tuples nommés (distincts les uns des autres, même si les types sous-jacents sont identiques), c'est un moyen de créer des types custom un chouïa plus légers que de faire des structs.

> Each struct you define is its own type, even though the fields within the struct might have the same types.

`unit-like structs` = structs "vides", i.e. sans aucun field.

> In the User struct definition in Listing 5-1, we used the owned String type rather than the &str string slice type. This is a deliberate choice because we want each instance of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.

^ une différence conceptuelle importante entre `String` et `&str` :

- les slices sont des références donc non-owning : quand le slice arrive en fin de vie, le texte n'est pas détruit
- alors que la `String` est owning : quand la `String` arrive en fin de vie, son texte est détruit

Apparemment, pour qu'une struct ait un field qui soit une référence vers quelque chose, il faut une feature supplémentaire = les `lifetimes`.

### Chapitre 5.2 = An Example Program Using Structs

https://doc.rust-lang.org/book/ch05-02-example-structs.html

Pour le moment, les structs ne sont présentées que comme des tuples permettant de nommer les fields.

Ndm : en rust, "prendre une référence sur un objet" se nomme "borrow un objet" (par opposition à "take it's ownership")

Quelques syntaxes utiles au passage en vrac :

```
#[derive(Debug)]
{:#?}
{:?}
dbg!
```

### Chapitre 5.3 = Method Syntax

https://doc.rust-lang.org/book/ch05-03-method-syntax.html

> To define the function within the context of Rectangle, we start an impl (implementation) block for Rectangle. Everything within this impl block will be associated with the Rectangle type.

^ C'est assez marrant en terme de syntaxe (mais au final pas beaucoup plus qu'en cpp) : la définition de la struct et de ses membres est séparée du bloc impl.

> In the signature for area, we use &self instead of rectangle: &Rectangle. The &self is actually short for self: &Self. Within an impl block, the type Self is an alias for the type that the impl block is for

^ Une méthode prend `&self` comme premier argument.

On peut avoir des properties comme en python pour implémenter des getters.

Rust infère l'objet à partir duquel on appelle une méthode, donc il n'y a qu'un unique opérateur `.`

> All functions defined within an impl block are called associated functions because they’re associated with the type named after the impl. We can define associated functions that don’t have self as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with.

^ équivalents des `staticmethod`...

> Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct. These are often called new, but new isn’t a special name and isn’t built into the language. 

^ ... ou des constructeurs !

Si besoin (en l'occurrence, pour implémenter des traits), on peut avoir plusieurs blocs impl pour une même struct.


## Chapitre 6 = Enums and Pattern Matching

> Enums allow you to define a type by enumerating its possible variants.

Exemples d'enum des adresses IP : il n'y a que deux possibilités = IPV4 ou IPV6.

Les variants des enums peuvent stocker des données :

```rs
enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }
```

Les variants des enums peuvent même être des structs, ou même d'autres enums.

On peut définir des méthodes d'enum dans des blocs impl !

Dans la suite, il prend l'exemple des `Option`, qui remplacent la valeur `Null` (ou `None`) que rust n'a pas, ce qui évite à chaque variable de pouvoir être nulle (ce qui évite la situation qu'on a p.ex. en C++, où un pointeur peut soit pointer soit sur un `T` valide, soit être un pointeur nul ; dit autrement, les pointeurs C++ sont obligatoirement des Optional).

À la place, on exprime explicitement avec `Option` les variables qui peuvent être nulles (e.g. le retour d'une fonction renvoyant le premier élément d'une liste va renvoyer `None` si la liste est vide) et ce qu'on y gagne de très important, c'est que toute variable qui n'est pas une `Option` ne peut pas être nulle, elle est forcément un `T` valide !

C'est exprimé plus succintement plus loin : `Option<T>` et `T` sont des types différents, on ne peut pas utiliser un `Option<T>` là où un `T` est attendu.

> Eliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value Option<T>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an Option<T>, you can safely assume that the value isn’t null.
>
> In general, in order to use an Option<T> value, you want to have code that will handle each variant. You want some code that will run only when you have a Some(T) value, and this code is allowed to use the inner T. You want some other code to run only if you have a None value, and that code doesn’t have a T value available. The match expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has.

La suite présente le pattern matching.

### The match Control Flow Construct

> Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.

C'est le pattern matching usuel. Attention, les matchs sont traitées dans l'ordre.

Les possibilités de match sont des **arms**, avec un pattern à gauche, et du code à droite (qui peut se passer de curly bracket `{...}` si le code est simple, ou les utiliser sinon)

> Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.

^ On peut binder un pattern à une valeur, pour l'utiliser dans le code de l'arm.

Un cas fréquent est `Option`, avec deux arms possibles : `None` et `Some(x)` , ce dernier cas bindant à `x` le contenu de l'`Option` :

```rs
match my_option {
    Some(x) => println!("here is the valid value: {x}"),
    None    => println!("there is no value"),
}
```

> Matches in Rust are exhaustive: we must exhaust every last possibility in order for the code to be valid

^ l'intérêt = le compilateur nous force à avoir prévu le code pour traiter _toutes_ les possibilités, sinon ça ne compile pas.

On peut définir un pattern catchall, en définissant une unique variable comme dernier match : elle attrapera tous les cas non traités (et si on n'utilise pas cette variable bindée, on peut l'appeler `_`) (et si on veut ne rien faire, on retourne un tuple vide = des parenthèses vides). Un catchall final qui ne fait rien s'écrit donc :

```rs
_ => ()
```

### Concise Control Flow with if let

`if let` permet en quelque sorte de convertir un bloc `match` en bloc `if`.

Dans certains cas (par exemple quand on est forcés de remplir tout un tas d'arms vides pour un bloc match), ça permet une syntaxe plus concise.

## Chapitre 7 = Managing Growing Projects with Packages, Crates, and Modules

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

Je n'annote pas (car mieux vaut construire ma compréhension de l'organisation du code sur de petits projets), mais ce chapitre décrit l'organisation du code :

> As a project grows, you should organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques.

## Chapitre 8 = Common Collections

https://doc.rust-lang.org/book/ch08-00-common-collections.html

Description de `Vec`, `String` et `HashMap`.

Ici aussi, inutile d'annoter, mieux vaut pratiquer.

À noter que le [sous-chapitre sur les strings](https://doc.rust-lang.org/book/ch08-02-strings.html) détaille la façon dont rust gère les chaînes de caractères, et notamment la différence entre byte (`u8`), point de code (scalar value), et "letter" (grapheme clusters).

## Chapitre 9 = Error Handling

https://doc.rust-lang.org/book/ch09-00-error-handling.html

Chapitre intéressant sur la gestion d'erreur.

Différence entre :

- les **recoverable errors** = sur lesquelles on peut agir
- les **unrecoverable errors** = on n'a rien de plus d'intelligent à faire que de planter

Les premières renvoient un `Result<T, E>`  ; avec notamment un pattern très utile = l'opérateur `?` qui permet de propager les erreurs.

Les secondes utilisent la macro `panic!`, éventuellement indirectement via `unwrap` ou `expect`.

Concernant l'opérateur `?`, en deux mots, suffixer une variable de type `Result` par l'opérateur `?` dit "utilise ce result comme s'il n'y avait pas eu d'erreur, et si jamais il y a eu une erreur, fais un `return` early avec l'erreur en question".

Les exemples avec et sans l'opérateur `?` sont très illustratifs de la concision qu'on y gagne :

```sh
// SANS = on a beaucoup de cas Err à traiter, ça pollue le code :
fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");
    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    let mut username = String::new();
    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => return Err(e),
    }
}


// AVEC = le code est beaucoup plus clair :
fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

À noter : obviously, il faut que le type de retour de la fonction à l'intérieur de laquelle on utilise `?` soit compatible, i.e. qu'elle retourne un `Result<T, E>`.

## Chapitre 10 = Generic Types, Traits, and Lifetimes

https://doc.rust-lang.org/book/ch10-00-generics.html

Fonctions, structs et enum peuvent être génériques (équivalent des templates en C++).

### Chapitre 10.1 = Generic Data Types

https://doc.rust-lang.org/book/ch10-01-syntax.html

Classiquement, on peut implémenter des méthodes génériques.

Plus surprenant, on peut définir une méthode qui n'existe que pour une spécialisation particulière d'une structure (NDM : si cette méthode est publique, c'est un peu bizarre car deux spécialisations différentes d'un même généric n'auront pas la même interface... Mais bon, c'est pas si différent que le nominal subtyping où on hérite d'une interface tout en ayant la possibilité d'ajouter des méthodes propres à la classe fille).

L'éventuel type générique du bloc `impl<T>` indique que l'implémentation porte sur toutes les spécialisations. Si on n'en précise pas, c'est que l'implémentation porte sur une spécialisation particulière :

```rs
// l'implémentation sera partagée par toutes les spécialisations du generic Point :
impl<T> Point<T> {

// l'implémentation est propre à la spécialisation du Point pour les f32 :
impl Point<f32> {
```

Le compilateur rust fonctionne comme en cpp : le généric est instancié à la compilation. Du coup il n'y a pas de runtime cost aux generics, qui sont compilés tout comme si on avait écrit les différentes spécialisations à la main.

### Chapitre 10.2 = Traits: Defining Shared Behavior

https://doc.rust-lang.org/book/ch10-02-traits.html#traits-defining-shared-behavior

> Traits are similar to a feature often called interfaces in other languages, although with some differences.

^ les traits permettent de définir des comportements qui seront partagés par plusieurs types , un peu comme des interfaces implémentées par différentes classes.

```rs
pub trait Summary {
    fn summarize(&self) -> String;
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
```

NDM = on dirait qu'on peut étendre des third-party classes, c'est à dire leur ajouter des comportements a posteriori, ce qui est un peu contre-intuitif vu qu'on ne peut plus connaître l'interface définitive d'une classe.

> Other crates that depend on the aggregator crate can also bring the Summary trait into scope to implement Summary on their own types

^ quand je code une crate, je peux importer un trait d'une autre crate pour que mes propres classes puissent l'implémenter.

> One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.

^ ceci et les exemples qui suivent montrent que c'est en fait logique :

- on peut ajouter à ses propres classes des comportements définis ailleurs (conceptuellement, c'est similaire à ce que notre classe hérite d'une third-party interface, ou se conforme à un third-party structural subtyping défini)
- on peut ajouter ses propres comportement à une third-party classe (conceptuellement, c'est proche du fait de créer une classe dérivée de la third-party class, voire à définir un C++-trait pour cette classe)
- mais on ne peut pas ajouter des comportements externes à des classes externes, sinon deux personnes différentes pourrait créer du code incompatible :

> This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.

Autre point auquel je ne suis pas habitué : pour utiliser une classe selon cette interface, il faut importer non seulement la classe, mais aussi le trait.

> Implementing a trait on a type is similar to implementing regular methods. The difference is that after impl, we put the trait name we want to implement, then use the for keyword, and then specify the name of the type we want to implement the trait for

^ la syntaxe pour implémenter un trait et une méthode est proche (ce qui est logique).

En implémentant un body au trait, ça fournit une implémentation par défaut.

Syntaxe pour une fonction acceptant en argument "n'importe quoi qui implémente le trait `Summary`" :

```rs
// Raccourci :
fn notify(item: &impl Summary) {
    // ...
}

// Version longue = trait bound :
fn notify<T: Summary>(item: &T) {
    // ...
}
```

Une fonction peut même exprimer qu'elle nécessite en argument un type qui implémente plusieurs traits :

```rs
fn notify(item: &(impl Summary + Display)) {
}

fn notify<T: Summary + Display>(item: &T) {
}
```

Enfin, il y a une troisième syntaxe plus verbeuse, mais plus explicite et claire :

```rs
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{ }
```

Similairement, une fonction peut retourner un type implémentant un trait :

```rs
fn returns_summarizable() -> impl Summary {
```

On peut définir une implémentation conditionnelle d'une fonction générique uniquement pour certains types = ceux qui implémentent un trait.

Dans le même genre, on peut implémenter un trait pour certains types = tous les types qui implémentent eux même un (autre) trait :

> We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called blanket implementations and are extensively used in the Rust standard library. For example, the standard library implements the ToString trait on any type that implements the Display trait. 

### Validating References with Lifetimes

https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

Spoiler alert : c'est un gros morceau.

> lifetimes ensure that references are valid as long as we need them to be.

^ ~~les lifetimes maintiennent les références en vie~~ EDIT : non, les lifetimes ne modifient pas la durée de vie des références, ce ne sont que des annotations permettant au borrow-checker de faire son boulot = de vérifier si toutes les références utilisées sont bien en vie = éviter une use-after-free.

> every reference in Rust has a lifetime, which is the scope for which that reference is valid.

^ toutes les références ont des lifetimes ...

> Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We only must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways

^ ... mais la plupart du temps, la lifetimes d'une référence est implicite, on ne doit la préciser que quand elle ne peut pas être inférée.

> Annotating lifetimes is not even a concept most other programming languages have, so this is going to feel unfamiliar.

^ _I brace myself_

Le cas d'exemple pour illustrer les lifetimes :

```rs
fn main() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

^ ce code ne compile pas, et le message d'erreur est clair :

```
`x` dropped here while still borrowed
```

^ au moment où `x` arrive en fin de vie (à la fin du scope intérieur), l'objet `x` (= l'entier 5) va être détruit, or `x` est toujours borrowed par `r` ! Du coup pour éviter un use-after-free, ça ne compile pas.

> So how does Rust determine that this code is invalid? It uses a borrow checker.

^ c'est le rôle du fameux borrow-checker que de vérifier qu'au moment où une variable arrive en fin de vie, il n'existe plus de référence (= de borrow) dessus.

> The Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid.

^ le métier du borrow-checker est de confirmer que tous les références sont valides.

Here, we’ve annotated the lifetime of r with 'a and the lifetime of x with 'b.

^ au moins dans la doc, on parle des lifetimes comme des variables, c'est rigolo (mais c'est vrai que la lifetime a bien un nom de variable, donc c'est logique).

Syntaxe : les lifetimes semblent préfixées par `'`

#### quel problème résout-on grâce aux lifetimes ?

```rs
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

^ l'exemple donné en fil rouge est clair et concis : une fonction `longest` acceptant deux string slices en input (donc des références), et retournant une string slice en output, pointant vers une des deux slices d'input = la plus longue.

> the return type needs a generic lifetime parameter on it because Rust can’t tell whether the reference being returned refers to x or y

^ Si on n'utilise pas les lifetimes, ça ne compile pas : le compilateur rust voit bien qu'on retourne soit une référence vers `x`, soit une référence vers `y`, mais il ne sait pas sur lequel des deux on retourne une référence, donc il ne connaît pas précisément la durée de vie de la référence en output (et ne peut donc pas vérifier par la suite qu'elle n'est pas utilisée après que l'objet référencé soit détruit).

NDM : sans encore avoir lu la suite, je suppose que le fait de ne pas savoir sur quelle référence le retour pointe est problématique, car ça empêche le borrow-checker de faire son taf : quid si l'une des deux références input arrive en fin de vie ?

> we can’t look at the scopes as we did (...) to determine whether the reference we return will always be valid. The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of x and y relate to the lifetime of the return value. To fix this error, we’ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.

^ Indeed, c'était bien l'idée : les lifetimes permettent de donner au borrow-checker les infos liant le cycle de vie des inputs et de l'output.

NDM : on aurait pu proposer que le borrow-checker soit conservateur, et traite la référence en output de façon pessimiste (en lui donnant la durée de vie de la pire des deux références input), mais :

- c'est inutilement pessimiste, donc
- ça peut empêcher d'implémenter certaines fonctions
- de toute façon, c'est faire un truc implicite derrière le dos de l'utilisateur : mieux vaut plutôt lui faire préciser ce qu'il veut.

> Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.

^ on n'utilise pas les lifetimes pour MODIFIER la durée de vie de références, mais pour connaître la durée de vie d'une référence (ici, la référence retournée en output) à partir de la durées de vie d'autres références (ici, les références acceptées en input).

Syntaxe :

```rs
&'a i32
&'a mut i32
```

> One lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other

^ histoire de bien comprendre leur rôle, ça vaut le coup de l'exprimer explicitement : une unique lifetime est inutile, puisque leur raison d'être est de lier PLUSIEURS références. J'ajoute que les lifetimes sont les lifetimes d'une référence (la notion de lifetime est forcément adossée à une référence).

> To use lifetime annotations in function signatures, we need to declare the generic lifetime parameters inside angle brackets between the function name and the parameter list, just as we did with generic type parameters.

^ du point de vue syntaxe, ça ressemble aux generics : la fonction est "paramétrée" par la lifetime.

> We want the signature to express the following constraint: the returned reference will be valid as long as both the parameters are valid.

^ c'est la façon de lire la signature suivante :

```rs
# the returned reference will be valid as long as both the parameters are valid :
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str
```

NDM : les lifetimes lient la durée de vie de l'output aux durées de vie des inputs (ce qui est logique).

Autre point : veut on vraiment lier le retour aux DEUX entrées ? Ça n'est pas forcément vrai dans le cas général, mais ici oui, car au runtime, le retour pourra nécessiter d'être en vie aussi longtemps que le premier input OU que le second input : les deux cas peuvent se produire. Du coup, à l'analyse statique (faite par le borrow-checker), il faut vérifier que l'output reste bien en vie aussi longtemps que les DEUX inputs, et donc lier la lifetime de l'output aux DEUX lifetimes des inputs.

> The function signature now tells Rust that for some lifetime 'a, the function takes two parameters, both of which are string slices that live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime 'a.

^ c'est une formulation intéressante, où la lifetime est en quelque sorte une variable d'entrée de la fonction.

> In practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the values referred to by the function arguments.

^ c'est bien comme ça que se lit la signature de la fonction, et c'est ce point que va vérifier le borrow-checker, grâce à nos jolies annotations de lifetimes.

> Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints

^ dit autrement, les lifetimes ne sont que des indications à destination de l'analyseur statique = le borrow-checker, mais ne changent rien au comportement du code (un peu comme les annotations python sont des indications à destination de mypy, mais ne changent rien au comportement du code).

> When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. The lifetime annotations become part of the contract of the function, much like the types in the signature

Les lifetimes annotations font partie de la signature des fonctions.

> the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter 'a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.

^ du point de vue du borrow-checker lorsqu'il analyse la fonction, toutes les lifetimes (y compris celle de la variable de retour) ont comme durée de vie celle de la référence de plus petite durée de vie.

C'est illustré par l'exemple suivant, qui est REFUSÉ par le borrow-checker :

```rs
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

^ en effet, au moment de l'appel à `println!`, `result` a une durée de vie égale à la plus petite durée de vie des deux références en input, soit celle de `string2`, dans le inner scope. Du coup, `println!` utilise la référence vers `result` en dehors du scope où elle est en vie ! L'erreur de compilation est qu'il considère que `string2` est toujours borrowed (par `result`, je suppose) au moment où elle arrive en fin de vie (= elle est dropped) lorsqu'on quitte l'inner scope.

Un autre exemple pour montrer que les lifetimes servent à lier le cycle de vie de références, et qu'il est donc inutile de les lier si elles n'ont aucun lien réel :

```rs
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

> We’ve specified a lifetime parameter 'a for the parameter x and the return type, but not for the parameter y, because the lifetime of y does not have any relationship with the lifetime of x or the return value.

^ il n'est pertinent de lier la return value qu'à `x`, vu que `y` n'a pas de lien avec la valeur de retour.

Un troisième exemple est particulièrement intéressant, le snippet essaye de retourner une référence sur une valeur créée dans la fonction, ce qui ne marche évidemment pas (puisque le valeur est détruite aussitôt qu'on sort de la fonction, donc la référence retournée ne peut être que dangling, ce que le borrow-checker n'autorise pas). La solution dans ce cas (au moins pour cet exemple) est de plutôt renvoyer une owning value.

> Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.

^ excellent résumé !

Utilisation dans les structs :

```rs
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

> (...) This annotation means an instance of ImportantExcerpt can’t outlive the reference it holds in its part field.

^ similairement, on peut lier le cycle de vie d'une struct aux cycles de vie des références qui la constituent (pour faire le lien avec les exemples précédents qui étaient données avec une fonction, la struct est alors l'équivalent de l'output de la fonction, et les membres sont équivalentes aux inputs)

**Lifetime elision**

En gros, certains patterns particuliers sont hardcodés dans le compilo, afin que préciser les lifetimes pour ces situations soit inutile :

> The patterns programmed into Rust’s analysis of references are called the lifetime elision rules. These aren’t rules for programmers to follow; they’re a set of particular cases that the compiler will consider, and if your code fits these cases, you don’t need to write the lifetimes explicitly
>
> Lifetimes on function or method parameters are called input lifetimes, and lifetimes on return values are called output lifetimes.

^ conceptuellement, il y a une différence entre input-lifetimes (= la lifetime des paramètres) et output-lifetimes (la lifetime de la sortie) ; l'idée est d'exprimer l'output en fonction des infputs.

Le paragraphe détaille les (trois) règles utilisées par le compilo pour inférer les lifetimes, je ne les annote pas.

Derrière, il y a un paragraphe sur les lifetimes dans les signatures des méthodes de classe.

Puis un paragraphe sur la lifetime `'static` qui signifie "pour toute la durée de vie du programme" :

```
let s: &'static str = "I have a static lifetime.";
```

Mais le point intéressant à ce sujet est surtout l'avertissement : le compilateur suggère souvent de passer une lifetime en static pour résoudre des soucis, mais à moins de vouloir un truc en vie pour toute la durée de vie du programme, la plupart du temps, ça n'est PAS ce qu'il faut faire (et le compilo induit donc en erreur : il ne faut pas suivre sa recommandation).

Pour conclure cet énorme chapitre, il donne un exemple mélangeant lifetimes, type générique et trait bound.

## Chapitre 11 = Testing

https://doc.rust-lang.org/book/ch11-00-testing.html

### 11.1. How to Write Tests

https://doc.rust-lang.org/book/ch11-01-writing-tests.html

Rust propose des features spécifiquement conçues pour aider au testing.

(NDM = une nouvelle occasion d'apprécier le caractère moderne du langage)

> At its simplest, a test in Rust is a function that’s annotated with the test attribute. (...) When you run your tests with the cargo test command, Rust builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails.

^ le test runner est intégré à cargo

> Whenever we make a new library project with Cargo, a test module with a test function in it is automatically generated for us.

^ si notre projet est une lib, il dispose automatiquement de tests (vides) par défaut, pour encourager la bonne pratique.

Je n'annote pas tout, voici les éléments importants :

- `#[test]` annotation
- les macros `assert` /  `assert_eq!`  / `assert_ne`
- `#[should_panic]` (+ `expected` pour n'attraper que les panics qui nous intéressent)
- `panic!` pour faire échouer un test

De même que pytest ne considère que les fonctions préfixées par `test_` comme des tests, ce qui nous laisse l'opportunité de créer des fonctions qui sont des helpers sans être des tests, rust ne considère que les fonctions annotés comme des tests.

On retrouve les features classiques des test runner, p.ex. ne lancer certains tests que sous condition. Il y a aussi des doctests.

> The tests module is a regular module that follows the usual visibility rules

^ Malgré les features spéciales, le module de test peut importer d'autres modules, tout comme un module normal. Notamment, il peut `use super::*;`

On peut écrire des tests qui renvoient un `Result<T, E>`, ce qui nous permet d'utiliser l'opérateur `?` dans leur implémentation.

### 11.2 Controlling How Tests Are Run

https://doc.rust-lang.org/book/ch11-02-running-tests.html#controlling-how-tests-are-run

```
cargo test
cargo test --help
cargo test -- --help
```

Si on s'assure que les tests ne partagent pas un état commun (p.ex. un fichier dans lequel ils écrivent), les tests peuvent être joués en parallèle.

Par défaut, seul le stdout des tests qui failent est affiché, à moins d'utiliser :

```
cargo test -- --show-output
```

Pour filtrer :

```
cargo test PATTERN
```

Annotation `#[ignore]` pour définir des tests qui ne sont pas lancés par défaut, et pour les jouer :

```
cargo test -- --ignored
```

### 11.3 Test Organization

https://doc.rust-lang.org/book/ch11-03-test-organization.html

> The Rust community thinks about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.

^ terminologie utilisée par la communauté rust pour les tests :

- **unit-tests** = tester un module en isolation
- **integration tests** = tester l'API publique de la librairie, comme n'importe lequel de ses clients

> The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected.

^ ce que je retiens des unit tests, c'est 1. qu'ils testent un module en isolation (donc sans impact des dépendances) et 2. qu'ils servent à localiser précisément les erreurs.

> You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named tests in each file to contain the test functions and to annotate the module with cfg(test).

^ l'usage en rust est de mettre les test unitaires dans le même fichier que le module, et d'utiliser l'annotation `#[cfg(test)]`

Au sein d'un module annoté par `#[cfg(test)]`, les fonctions annotées par `#[test]` sont des tests qui seront exécutés par le runner, et les autres sont des fonctions utilitaires qui seront compilées et potentiellement utilisées pares tests, mais qui ne seront pas exécutées par le runner.

> You’ll see that because integration tests go in a different directory, they don’t need the #[cfg(test)] annotation.

^ les tests d'intégration étant indépendants, ils n'ont pas besoin de cette annotation.

> Testing Private Functions. There’s debate within the testing community about whether or not private functions should be tested directly

En gros, comme les tests sont dans le même fichier que le code, ils peuvent avoir accès au code privé (et peuvent le tester). Comme c'est un sujet controversé, rien n'oblige ni interdit de le faire.

> In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library’s public API. Their purpose is to test whether many parts of your library work together correctly.

^ Les tests d'intégration selon rust. Ils vont dans un répertoire `tests` au même niveau que `src`.

> Each file in the tests directory is a separate crate, so we need to bring our library into each test crate’s scope. (...) Cargo treats the tests directory specially and compiles files in this directory only when we run cargo test.

^ j'ajoute qu'il faut tout de même dire à rust quelles sont les fonctions qui sont des tests à exécuter avec `#[test]`

Il y a une convention spéciale pour définir du code utilitaire réutilisable par plusieurs tests d'intégration, je ne détaille pas ici.

> Integration Tests for Binary Crates

En gros, comme un main n'est pas testable directement, mieux vaut définir son code sous forme d'une librairie (qu'on pourra tester avec des tests d'intégration) qu'un main (devenu anémique, ce qui est une bonne chose) appelle.

> Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the library’s public API to test the code in the same way external code will use it.

^ résumé

## Chapitre 12 = An I/O Project: Building a Command Line Program

https://doc.rust-lang.org/book/ch12-00-an-io-project.html#an-io-project-building-a-command-line-program

Ce chapitre est un petit projet d'application = faire un clone de grep. Comme c'est surtout de la pratique, je n'annote pas (ou très peu).

> We can use the collect function to create many kinds of collections, so we explicitly annotate the type of args to specify that we want a vector of strings. (...) Although we very rarely need to annotate types in Rust, collect is one function you do often need to annotate because Rust isn’t able to infer the kind of collection you want.

^ ceci explique que j'ai dû annoter le type dans l'une de mes pocs.

> the Rust community has developed guidelines for splitting the separate concerns of a binary program when main starts getting large. This process has the following steps:
>
> - Split your program into a main.rs and a lib.rs and move your program’s logic to lib.rs.
> - As long as your command line parsing logic is small, it can remain in main.rs.
> - When the command line parsing logic starts getting complicated, extract it from main.rs and move it to lib.rs.
>
> The responsibilities that remain in the main function after this process should be limited to the following:
>
> - Calling the command line parsing logic with the argument values
> - Setting up any other configuration
> - Calling a run function in lib.rs
> - Handling the error if run returns an error
>
> (...)  this structure lets you test all of your program’s logic by moving it into functions in lib.rs. The code that remains in main.rs will be small enough to verify its correctness by reading it

^ **IMPORTANT** = les bonnes pratiques rust pour écrire un main.

Traitement idiomatique des erreurs :

```
 let config = Config::build(&args).unwrap_or_else(|err| {
     println!("Problem parsing arguments: {err}");
     process::exit(1);
 });
```

Après que le main a fait le parsing des paramètres passés sur la CLI dans un objet `Config`, le coeur du traitement est délégué à une fonction `run` qui prend un `Config` en paramètre et retourne un `Result`.

À noter que le type de retour m'est encore inconnu (EDIT : sauf erreur, c'est le type d'une erreur heap-allocated dont le type exact n'est pas connu au compile-time, mais qui implémentera le trait `Error`) :

```
fn run(config: Config) -> Result<(), Box<dyn Error>>
```

> For now, just know that Box<dyn Error> means the function will return a type that implements the Error trait, but we don’t have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases.

^ on retourne quelque chose qui implémente le trait `Error`, je n'en saurais pas beaucoup plus pour le moment.

À noter que comme la fonction retourne `()`, c'est donc qu'on ne l'appelle que pour profiter de ses side effects.

Au final, la première étape est de setup le canevas du projet, avec une fonction `main` qui parse les arguments, appelle `run`, et gère les erreurs ; et une fonction dans la lib qui fera tout le boulot (vide pour le moment).

Derrière, il fait du TDD pour implémenter la fonction de recherche.

Puis, il configure le comportement par envvar :

> We’ll improve minigrep by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. 

`eprintln!` = équivalent de `println!` mais qui écrit sur stderr au lieu de stdout.

## Chapitre 13 = Functional Language Features: Iterators and Closures

https://doc.rust-lang.org/book/ch13-00-functional-features.html#functional-language-features-iterators-and-closures

### 13.1. Closures: Anonymous Functions that Capture Their Environment

https://doc.rust-lang.org/book/ch13-01-closures.html

Les closures sont des lambdas qui capturent automatiquement ce dont elles ont besoin dans leur **contexte** :

```rs
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

^ exemples de syntaxe de closure. Les annotations sont inutiles la plupart du temps, mais les trois closures sont équivalentes.

À noter que pour les closures sans annotations, il faut que le code utilise réellement la closure pour que l'inférence sans annotation puisse se faire (ce qui est forcément le cas, sinon la closure est du code mort).

Attention que même si une closure non annotée peut être appelée avec n'importe quel type, la closure n'est pas paramétrée sur le type inféré (i.e. ce n'est pas un template) :

```rs
 let example_closure = |x| x;

 let s = example_closure(String::from("hello"));
 let n = example_closure(5);
```

^ ainsi, la dernière ligne ne compile pas :

> The first time we call example_closure with the String value, the compiler infers the type of x and the return type of the closure to be String.
>
> Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.

^ contrairement au C++ où on décrit explicitement ce qu'on capture, en rust, _ce qui est capturé est inféré à partir de ce qui est utilisé dans le body de la closure_.

Du coup attention : si on mute une référence dans une closure (plus précisément : au moment où on définit la closure, y compris si on ne l'appelle que beaucoup plus tard), alors il ne doit pas exister d'autre référence, y compris immutable, sinon le borrow-checker ne l'autorisera pas. La référence mutable est libérée à la fin du dernier appel de la closure.

> If you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the move keyword before the parameter list.

^ pour que la closure move les objets utilisés dans son body plutôt que de simplement les référencer. Peu utilisé : c'est surtout pour transférer des données à un nouveau thread. La syntaxe est un peu spéciale :

```rs
thread::spawn(move || println!("From thread: {:?}", list))
```

^ ici, `list` est moved dans la closure, et n'est donc plus utilisable après définition de la closure.

> even though the closure body still only needs an immutable reference, we need to specify that list should be moved into the closure by putting the move keyword at the beginning of the closure definition.

^ le move est nécessaire car dans un contexte multithreadé, si un thread a une référence et un autre a la valeur owned ET que le thread qui a l'owned se termine plus tôt que celui qui a la référence, alors la valeur référencée arrive en fin de vie trop tôt. (NDM si on omettait le move, on serait donc dans un cas de non-robustesse que le compilo rust n'attrape pas ? EDIT : non, le compilo rust n'autorise même pas à ne pas move la valeur).

> Therefore, the compiler requires that list be moved into the closure given to the new thread so the reference will be valid. Try removing the move keyword or using list in the main thread after the closure is defined to see what compiler errors you get!

^ ah ben non, le compilo attrape bien la non-robustesse !

> The way a closure captures and handles values from the environment affects which traits the closure implements, and traits are how functions and structs can specify what kinds of closures they can use. Closures will automatically implement one, two, or all three of these Fn traits, in an additive fashion, depending on how the closure’s body handles the values:
>
> - FnOnce (...)
> - FnMut (...)
> - Fn (...)

Il y a trois traits cumulables possibles pour caractériser une fonction ou une closure (qui permettent à du code acceptant une closure de préciser quel type de closure il accepte)

NDM : le truc important, c'est que c'est au moment de la **déclaration** de la closure (e.g. `let myclosure = |x| x`) que la capture a lieu , et donc que des valeurs sont moved, ou que des références deviennent inutilisables.

Derrière, c'est lors du premier appel (et des suivants) que les valeurs sont éventuellement "rendues à l'appelant" (moved out = quand la closure renvoie une owned-value, éventuellement celle qu'elle avait capturée) et que les références qui étaient capturées sont détruites.

Du coup, c'est le body de la closure qui fixe les traits. Par exemple, une closure qui move-out un paramètre qui avait été capturé par move-in n'est utilisable qu'une fois, car dès le premier appel, la valeur qui avait été moved-in lors de la déclaration est moved-out par l'appel et n'est donc plus utilisable par les appels suivants (plus bas, le listing 13.8 donne un exemple concret, ce qui aide à la compréhension).

> Functions can implement all three of the Fn traits too. If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure where we need something that implements one of the Fn traits.

^ Les traits `Fn` sont implémentés par les fonctions aussi : partout où on peut passer une closure, on peut passer une fonction par son nom.

### 13.2. Processing a Series of Items with Iterators

https://doc.rust-lang.org/book/ch13-02-iterators.html

> In Rust, iterators are lazy, meaning they have no effect until you call methods that consume the iterator to use it up.

^ les iterators sont lazy : créer un iterator ne fait rien, c'est l'utiliser qui fait quelque-chose.

> All iterators implement a trait named Iterator that is defined in the standard library.

^ un iterator, c'est quelque chose sur lequel on peut appeler `next()`, avec un _associated type_ `Item`.

> The Iterator trait only requires implementors to define one method: the next method, which returns one item of the iterator at a time wrapped in Some and, when iteration is over, returns None.

^ `next()` renvoie une `Option`, et quand l'iterator est vidé, l'option contient le variant `None`.

> Note that we needed to make v1_iter mutable: calling the next method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code consumes, or uses up, the iterator. Each call to next eats up an item from the iterator. We didn’t need to make v1_iter mutable when we used a for loop because the loop took ownership of v1_iter and made it mutable behind the scenes.

^ pour itérer sur un iterator, il faut le muter. La boucle for le fait derrière notre dos.

> The iter method produces an iterator over immutable references.

^ `iter()` permet d'itérer sur des références immutables ; si on veut muter (ou prendre l'ownership) de valeurs itérées, il faut utiliser `iter_mut` ou `into_iter`.

> Methods that call next are called consuming adaptors, because calling them uses up the iterator. One example is the sum method,

^ quand on a un iterator, on gagne des méthodes de la lib standard. EDIT : il y en a moultes, qui permettent d'exprimer l'intention des traitements qu'on veut faire de façon très expressive : cf. les _Provided methods_ de [la doc](https://doc.rust-lang.org/std/iter/trait.Iterator.html)

> Iterator adaptors are methods defined on the Iterator trait that (...) produce different iterators by changing some aspect of the original iterator

^  Certaines méthodes consomment l'iterator (par exemple `count`), d'autres méthodes modifient l'iterator, par exemple `map` qui modifie tous les items en leur appliquant une lambda.

### 13.3. Improving Our I/O Project

https://doc.rust-lang.org/book/ch13-03-improving-our-io-project.html

> The env::args function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to Config::build, now we’re passing ownership of the iterator returned from env::args to Config::build directly.

^ résumé de cette partie : on améliore l'IO projet du chapitre 12 pour éviter un clone de `String` inutile = on utilise directement l'iterator sur les arguments, plutôt que de l'utiliser pour construire un `Vector`, puis devoir cloner les string qu'il contient dans la config.

La nouvelle signature est :

```rs
fn build(
        mut args: impl Iterator<Item = String>,
    ) -> Result<Config, &'static str> {
```
 L'iterator doit être mutable vu qu'on le consomme.

Derrière, on peut aussi remplacer une boucle for par un pipeline de streams :

```rs
contents
    .lines()
    .filter(|line| line.contains(query))
    .collect()
```

^ en rust, ceci est considéré comme plus idiomatique que la boucle for équivalente.

### 13.4. Comparing Performance: Loops vs. Iterators

https://doc.rust-lang.org/book/ch13-04-performance.html

> The point is this: iterators, although a high-level abstraction, get compiled down to roughly the same code as if you’d written the lower-level code yourself. Iterators are one of Rust’s zero-cost abstractions, by which we mean using the abstraction imposes no additional runtime overhead.

^ les iterators sont une zero-cost abstraction.

## 14. More about Cargo and Crates.io

https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html

On peut customiser les profils de compilation avec une section `[profile.dev]` dans le `Cargo.toml `. Par défaut, deux profils dispos = dev et release.

Il y a un chapitre sur la publication de ses propres crates sur crate.io qui parle un peu des _documentation comments_ = des commentaires qui finiront dans la doc publique :

> The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to use your crate as opposed to how your crate is implemented.

Syntaxe : `/// ce commentaire est pour la documentation`

Le commentaire`///`  est placé juste avant l'item à documenter (par exemple une fonction) et markdown est supporté par ce type de commentaire.

> We typically use these doc comments inside the crate root file (src/lib.rs by convention) or inside a module to document the crate or the module as a whole.

^ le commentaire `//!` est placé _à l'intérieur_ de l'item à documenter.

`cargo doc [--open]` pour générer la documentation

Sections idiomatiques = `Examples`, `Panic`, `Errors`, `Safety`

Le code dans `Examples` est lancé automatiquement en tant que doctest par `cargo test`.

Re-export : `pub use` permet d'exposer dans l'API publique des trucs enfouis dans des modules plus deep, et ainsi façonner finement l'API publique d'une lib. Notamment, les trucs qu'on a choisi d'exposer apparaissent plus clairement dans la doc autogénérée.

Quand on publie une crate, les metadata sont à ajouter à la section `[package]` de Cargo.toml, et c'est le couteau suisse `cargo` qui sert à publier.

### 14.3. Cargo Workspaces

https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html

> A workspace is a set of packages that share the same Cargo.lock and output directory.

^ un workspace permet de découper son projet en plusieurs crates "indépendantes". Les crates peuvent si elles le souhaitent s'utiliser les unes les autres.

> We’ll have a workspace containing a binary and two libraries.

^ par exemple, un projet avec trois crates : deux librairies, et un main qui utilise les deux libs.

Un `Cargo.toml` chapeau configure le workspace : au lieu d'avoir une section `[package]` , il a une section `[workspace]` contenant un item de config `members` qui liste les sous-crate.

Chaque sous-crate a son propre `Cargo.toml`

> The workspace has one target directory at the top level that the compiled artifacts will be placed into; the adder package doesn’t have its own target directory. (...) Cargo structures the target directory in a workspace like this because the crates in a workspace are meant to depend on each other.

^ les sous-crates sont "indépendantes", mais peuvent s'utiliser les une les autres.

Pour créer des sous-crates, on a juste à :

- ajouter une entrée à `members`
- faire un `cargo new` normal dans un sous répertoire du workspace

> Cargo doesn’t assume that crates in a workspace will depend on each other, so we need to be explicit about the dependency relationships.

^ pour que les sous-crates s'utilisent les unes les autres, il faut ajouter chaque sous-crate qui sera utilisée comme dépendance dans le Cargo.toml de la sous-crate utilisatrice :

```toml
[dependencies]
add_one = { path = "../add_one" }
```

Derrière, on peut alors les utiliser comme n'importe quelle dépendance :

```
use add_one;
```

> Notice that the workspace has only one `Cargo.lock` file at the top level, rather than having a Cargo.lock in each crate’s directory. This ensures that all crates are using the same version of all dependencies.

^ les crates d'un même projet sont "indépendantes", mais elles partagent tout de même exactement les mêmes versions dépendances. Elles seront donc toujours compatibles entre elles. Pour qu'une sous-crate utilise une dépendance, elle doit tout de même la déclarer dans son propre sous `Cargo.toml`

Les binaires et les test des sous-crates peuvent être lancés depuis le workspace top-level.

> If you publish the crates in the workspace to crates.io, each crate in the workspace will need to be published separately.

^ ceci m'est moins clair : on dirait qu'on ne peut pas livrer l'ensemble du workspace (ce qui nous forcerait à livrer plein de sous crates inutiles en soi, pour pouvoir utiliser la carte du binaire global ? Ça me paraît bizarre, j'ai dû mal comprendre, il faudrait que je voie comment fait ripgrep).

----

> The cargo install command allows you to install and use binary crates locally. (...) it’s meant to be a convenient way for Rust developers to install tools that others have shared on crates.io. Note that you can only install packages that have binary targets.

^ grâce à **cargo install** crates.io joue aussi le rôle de repository pour des crates binaires, qui sont donc directement installables pour l'utilisateur.

> This isn’t intended to replace system packages

^ ... mais c'est pourtant yet another tool pour installer des trucs sur son système ^^

Last but not least, on peut définir ses propres commandes cargo custom.

## Chapitre 15 = Smart Pointers

https://doc.rust-lang.org/book/ch15-00-smart-pointers.html

Les références sont des pointeurs qui borrowent la valeur pointée.

> Smart pointers, on the other hand, are data structures that act like a pointer but also have additional metadata and capabilities. (...) Rust, with its concept of ownership and borrowing, has an additional difference between references and smart pointers: while references only borrow data, in many cases, smart pointers own the data they point to.

^ les smart pointers "contiennent" de la donnée, avec des features en plus. `String` et `Vec<T>` sont des exemples de smart pointers.

Les smart pointers implémentent les traits `Deref` (qui permettent de manipuler le contenu pointé comme une référence) et `Drop` qui permettent de customiser le comportement quand le smart pointer est détruit (NDM : pour libérer la ressource du smart-pointer).

### 15.1. Using Box<T> to Point to Data on the Heap

https://doc.rust-lang.org/book/ch15-01-box.html

> Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.

^ le contenu d'un `Box` est stocké sur le heap.

> You’ll use them most often in these situations:
>
> - When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size
> - When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so
> - When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type

^ les trois situations où on veut utiliser un Box. Le premier cas est décrit dans ce chapitre, et le troisième au chapitre 17. Ma compréhension du second, c'est que quand on passe des objets par valeur à une fonction(en transférant l'ownership), les données sont copiées dans la stackframe de la fonction. Du coup, quand on veut éviter cette copie, il faut un smart pointer pour implémenter une move-semantics efficace.

#### Using a Box<T> to Store Data on the Heap

```
let b = Box::new(5);
```

^ ici, l'entier a été heap-allocated. À noter que derrière, on l'utilise pourtant avec la même syntaxe qu'un objet classique.

Lorsqu'un Box arrive en fin de vie, les données sur le heap sont desallouées (ainsi que le box lui même sur la stack, comme n'importe quelle valeur sur la stack, vue jusqu'ici dans ce book)

#### Enabling Recursive Types with Boxes

> A value of recursive type can have another value of the same type as part of itself.

^ exemple concret d'utilisation des `Box` = un tree

> Recursive types pose an issue because at compile time Rust needs to know how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Rust can’t know how much space the value needs.

Les recursive types ne sont PAS implémentables classiquement.

> A cons list (...) is made up of nested pairs, and is the Lisp version of a linked list.
>
> (1, (2, (3, Nil)))

L'exemple pour illustrer simplement l'intérêt des Box est une paire recursive (le second élément de la paire est soit une paire récursive soit Nil) appelée _cons-list_

```rs
enum List {
    Cons(i32, List),
    Nil,
}
```

^ définir un enum récursif sans `Box` ne compile pas car rust n'arrive pas à calculer la taille du type !

#### Computing the Size of a Non-Recursive Type

Quand rust rencontre un enum, il détermine sa taille comme étant celle du plus grand de ses variants.

#### Using Box<T> to Get a Recursive Type with a Known Size

```rs
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

^ définir un enum avec `Box` résout le problème, car la taille de la structure sur la stack devient connue : c'est celle d'un entier + un pointeur.

> Conceptually, we still have a list, created with lists holding other lists, but this implementation is now more like placing the items next to one another rather than inside one another.

^ j'aime beaucoup cette façon de voir les choses, et on voit immédiatement que grâce à ce petit changement, il devient possible d'attribuer une taille à chaque "noeud". On passe d'une liste récursive à une liste simplement chaînée.

> Boxes provide only the indirection and heap allocation; they don’t have any other special capabilities, like those we’ll see with the other smart pointer types. (...) they can be useful in cases like the cons list where the indirection is the only feature we need.

^ les Box ne sont qu'un exemple assez limité de smart pointers.

### 15.2. Treating Smart Pointers Like Regular References with the Deref Trait

https://doc.rust-lang.org/book/ch15-02-deref.html

Ce sous chapitre et le suivant traitent des deux traits propres aux smart pointers : `Deref` et `Drop`

> Implementing the Deref trait allows you to customize the behavior of the dereference operator *

^ Implémenter `Deref` permet de surcharger l'opérateur `*` mais c'est pas encore hyper clair quand on s'en sert (car il me semblait que son usage implicite), mais la suite de l'article l'expliquera sûrement.

> By implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.

^ c'est sans doute l'usage implicite en question. Par exemple, on utilise une référence vers un objet sans la dereferencer, même si une référence est en fait un pointeur. C'est d'ailleurs confirmé un peu plus bas :

```rs
let x = 5;
let y = &x;

assert_eq!(5, x);
assert_eq!(5, *y);
```

^ les références sont en fait des pointeurs ! Théoriquement, il faudrait les déréférencer pour les utiliser. `x` est en i32 et `y`  est une référence vers un i32. Et d'ailleurs, à ma surprise, ceci ne compile pas : `assert_eq!(5, y)`

```rs
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

^ Box n'est pas un pointeur, pourtant on peut le déréférencer de façon transparente comme une référence ! Car `Box` implémente `Deref`.

Pour la suite, on définit une struct générique `MyBox<T>` qui imite Box<T>, elle va nous servir de fil rouge.

De base, notre `MyBox` n'est pas déréférençable, on ne peut pas écrire `assert_eq!(5, *y)` si y est un MyBox !

> The Deref trait, provided by the standard library, requires us to implement one method named deref that borrows self and returns a reference to the inner data.

^ spec du trait `Deref`.

```rs
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

^ exemple d'implémentation

> .0 accesses the first value in a tuple struct

^ ceci explique certainement l'utilisation du pattern newtype : newtype est un tuple à un élément = le type wrappé, donc pour utiliser le type wrappé, on fait `monnewtype.0`.

> The deref method gives the compiler the ability to take a value of any type that implements Deref and call the deref method to get a & reference that it knows how to dereference.

^ `Deref` permet de récupérer une référence sur ses données, qu'on peut alors déréférencer. Les deux lignes suivantes sont équivalentes :

```rs
*y
*(y.deref())
```

> Rust substitutes the * operator with a call to the deref method and then a plain dereference so we don’t have to think about whether or not we need to call the deref method. This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements Deref.

^ si un type implémente Deref, l'utiliser comme une référence classique est straightforward.

### 15.3. Running Code on Cleanup with the Drop Trait

https://doc.rust-lang.org/book/ch15-03-drop.html

> Drop, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the Drop trait on any type, and that code can be used to release resources like files or network connections.

^ drop permet le RAII

Tout est intuitif ici, la méthode `drop` est appelée quand une variable arrive en fin de scope. Sa signature est :

```rs
fn drop(&mut self)
```

> you have to call the std::mem::drop function provided by the standard library if you want to force a value to be dropped before the end of its scope.

^ si jamais on veut libérer une ressource avant la fin du scope (e.g. déverrouiller un lock), on peut le faire avec `std::mem::drop`, car rust interdit d'appeler la méthode `.drop()` d'un objet directement.

> the ownership system that makes sure references are always valid also ensures that drop gets called only once when the value is no longer being used.

^ grâce à l'ownership, on est sûr de ne jamais dropper une valeur qui n'a pas encore fini d'être utilisée.

### 15.4. Rc<T>, the Reference Counted Smart Pointer

https://doc.rust-lang.org/book/ch15-04-rc.html

> In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. (...) The Rc<T> type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.

^ `Rc` est l'équivalent des shared_ptr du C++

RC = Reference Counting

> We use the Rc<T> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.

^ intéressante formulation : c'est quand on ne peut pas connaître au compile time l'owner précis d'une value qu'on peut vouloir utiliser un RC.

> Note that Rc<T> is only for use in single-threaded scenarios.

^ Rc est à réserver aux contextes monothreadés.

L'exemple de la cons liste du premier chapitre est repris, en le modifiant un peu afin qu'utiliser Box ne fonctionne pas, et qu'on doive utiliser Rc.

`Rc::new` créé la Rc, `Rc::clone` incrémente le compteur d'une Rc déjà existante.

> We could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case.

^ une convention à suivre.

> We don’t have to call a function to decrease the reference count like we have to call Rc::clone to increase the reference count: the implementation of the Drop trait decreases the reference count automatically when an Rc<T> value goes out of scope.

Tout comme en C++, c'est le destructeur qui décrémente le compteur.

> Via immutable references, Rc<T> allows you to share data between multiple parts of your program for reading only.

^ le partage d'ownership est readonly, pour muter la donnée partagée, il faut utiliser `RefCell`.

### 15.5. RefCell<T> and the Interior Mutability Pattern

https://doc.rust-lang.org/book/ch15-05-interior-mutability.html

> Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.

Mon cas était mon serveur web qui nécessitait une référence immutable sur un truc calculant des itinéraires, mais je voulais tout de même muter ce truc pour lui faire mémoriser les requêtes.

> To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that we’re checking the rules manually instead of relying on the compiler to check them for us;

Brace yourself, on va utiliser `unsafe`.

> With references and Box<T>, the borrowing rules’ invariants are enforced at compile time. With RefCell<T>, these invariants are enforced at runtime. With references, if you break these rules, you’ll get a compiler error. With RefCell<T>, if you break these rules, your program will panic and exit.

^ `RefCell` permet de ne vérifier les borrowing rules qu'au runtime.

Pour que tout le monde puisse se fier au compilateur, ce dernier est volontairement conservateur : quand il n'arrive pas à vérifier des propriétés du programme statiquement (et il ne le peut pas toujours, cf. p.ex. le problème de l'arrêt qui montre qu'on ne peut pas toujours tout inférer à partir d'un programme), dans le doute, il rejette le programme = il ne compile pas.

> The RefCell<T> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.

^ c'est quand on est dans une telle situation, mais que nous humains, on peut garantir que tout va bien qu'on utilise `RefCell`.

> RefCell<T> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context

^ ici aussi, `RefCell` est réservé à des programmes monothreadés.

> Mutating the value inside an immutable value is the interior mutability pattern

^ **interior mutability** = ça ressemble au keyword `mutable` du C++ (qui autorise à muter un attribut d'une instance `const`) : on peut muter un truc interne à un objet immutable.

> RefCell<T> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a panic! instead of a compiler error.

^ `RefCell` vérifie les règles d'ownership au runtime.

> A Use Case for Interior Mutability: Mock Objects

^ Les mocks sont un cas où on peut avoir besoin de l'interior mutability, puisque l'interface d'utilisation du mock peut imposer d'utiliser une référence immutable, mais on veut quand même pouvoir muter le mock, par exemple pour enregistrer les appels qu'il effectue (c'était exactement mon cas d'usage d'il y a deux jours).

**TL;DR** Le `RefCell` se manipule comme une valeur classique (par exemple il peut être un field d'un objet) et quand on a besoin d'une référence immutable sur cette valeur, on appelle `borrow()` (ou `mutable_borrow()` si on veut une référence mutable). Au runtime, le programme plantera si on appelle `borrow()` alors qu'il existe encore un `mutable_borrow()` en vie, ou le contraire.

> A common way to use RefCell<T> is in combination with Rc<T>. Recall that Rc<T> lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate!

^ classiquement, Rc ne permet de partager que des objets immutables. En partageant un objet immutable... de type RefCell, on peut muter l'objet immutable et contourner la limitation, et donc partager des objest mutables.

### 15.6. Reference Cycles Can Leak Memory

https://doc.rust-lang.org/book/ch15-06-reference-cycles.html

> Rust allows memory leaks by using Rc<T> and RefCell<T>: it’s possible to create references where items refer to each other in a cycle.

^ **ATTENTION** : à cause des reference-cycles, les memory-leaks restent possibles en rust (comme en python, d'ailleurs, s'il n'y avait pas le garbage collector).

La suite du paragraphe explore un exemple.

> If you have RefCell<T> values that contain Rc<T> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them.

^ il faut être prudent si on combine interior mutability et reference counting.

> Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped.

^ le principe des weaks references est que certaines références sont non-owning.

> the weak_count doesn’t need to be 0 for the Rc<T> instance to be cleaned up

^ en gros, la présence de weak references n'empêchera pas la valeur d'arriver en fin de vie dès que le nombre de strong références arrive à zéro.

Du coup, pour avoir le droit d'utiliser une weakref, il faut d'abord vérifier que l'objet pointé est toujours en vie, ce qui se fait en promouvant la weakref en strongref. Cet upgrade peut échouer, si la weakref pointait sur un objet détruit (l'upgrade renvoie donc une Option).

L'exemple donné par l'article est un arbre où les nœuds parents ownent les enfants, et où les enfants ont connaissance de leur parent via une weakref :

> A node will be able to refer to its parent node but doesn’t own its parent. (...) By specifying that the relationship from a child to its parent should be a Weak<T> reference in the definition of Node, you’re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.

Le résumé synthétise bien les smarts pointers de ce chapitre :

> - The Box<T> type has a known size and points to data allocated on the heap.
> - The Rc<T> type keeps track of the number of references to data on the heap so that data can have multiple owners.
> - The RefCell<T> type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.
> - We explored reference cycles that can cause memory leaks and how to prevent them using Weak<T>.

## Chapitre 16 = Fearless Concurrency

https://doc.rust-lang.org/book/ch16-00-concurrency.html

À partir d'ici, j'essaye de réduire un peu le volume des notes : j'ai en effet tendance à un peu trop tout citer, et non seulement ça ne sert pas à grand chose, mais en plus ça ralentit ma lecture.

### 16.1. Using Threads to Run Code Simultaneously

https://doc.rust-lang.org/book/ch16-01-threads.html

> The Rust standard library uses a 1:1 model of thread implementation, whereby a program uses one operating system thread per one language thread.

^ en rust, pas de green-threads ou de goroutines, on est dans du 1 pour 1.

Snippet illustratif :

```rs
let handle = thread::spawn(move || { /* ... */});
//...
handle.join().unwrap();
```

^ on crée un thread avec `thread.spawn` + une closure, souvent avec `move` pour qu'elle capture son contexte par valeur plutôt que par référence.

Si elle capturait son contexte par référence, un thread T1 possèderait la valeur, un thread T2 possèderait la référence. Si le scheduler de l'OS fait que T1 se termine avant T2, alors la valeur serait détruite, et la référence que T2 possède deviendrait dangling.

### 16.2. Using Message Passing to Transfer Data Between Threads

https://doc.rust-lang.org/book/ch16-02-message-passing.html

> One increasingly popular approach to ensuring safe concurrency is message passing (...) Rust's standard library provides an implementation of channels. A channel is a general programming concept by which data is sent from one thread to another. (...) A channel has two halves: a transmitter and a receiver.

^ ce chapitre est dédié à la communication multithread avec des **channels**.

> mpsc stands for multiple producer, single consumer. In short, the way Rust’s standard library implements channels means a channel can have multiple sending ends that produce values but only one receiving end that consumes those values.

^ les channels sont Multiple Senders, Single Consumer

```rs
let (tx, rx) = mpsc::channel();

 thread::spawn(move || {
     let val = String::from("hi");
     tx.send(val).unwrap();
 });

 let received = rx.recv().unwrap();
```

^ snippet de base des channels.

L'ownership de la valeur est transférée au channel (puis au receiver).

Snippet pour utiliser plusieurs senders :

```rs
let (tx, rx) = mpsc::channel();
let tx1 = tx.clone();
```

### 16.3. Shared-State Concurrency

https://doc.rust-lang.org/book/ch16-03-shared-state.html

> In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time.

^ une différence conceptuelle importante entre channels et shared-state.

Snippet d'utilisation d'un `Mutex` :

```rs
let m = Mutex::new(5);
{
    let mut num = m.lock().unwrap();
    *num = 6;
}
```

^ Par rapport à des mutex dans d'autres langages, ici, il n'est pas indépendant : il est lié à une valeur en particulier.

Par ailleurs, en plus de pouvoir bloquer le thread courant (comme classiquement : si le mutex est locké par un autre thread), l'appel à `lock` peut **échouer** : si un thread qui avait locké le mutex a paniqué sans l'avoir libéré.

Snippet de partage d'un mutex entre plusieurs threads :

```rs
let counter = Arc::new(Mutex::new(0));
let mut handles = vec![];

for _ in 0..10 {
    let counter = Arc::clone(&counter);
    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();
        *num += 1;
    });
    handles.push(handle);
}
```

^ on partage l'ownership du mutex avec un reference counter car on ne peut pas `move` le mutex plusieurs fois (ici, on veut bien partager l'ownership entre tous les threads, c'est donc bien un Rc qu'il faut utiliser). Par ailleurs, Rc n'étant pas threadsafe, c'est son équivalent atomic `Arc` (Atomic Reference Counter) qu'on utilise.

> You might have noticed that counter is immutable but we could get a mutable reference to the value inside it; this means Mutex<T> provides interior mutability, as the Cell family does

^ les mutex offrent une forme d'interior mutability, puisqu'on a pu les muter (pour les locker) alors qu'on utilisait une référence immutable dessus.

Note finale : le compilo rust et les Mutex empêchent les data races, mais n'empêcheront pas les deadlocks, qui sont une erreur logique.

### 16.4. Extensible Concurrency with the Sync and Send Traits

https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html

Résumé du paragraphe :

- `Send` et `Sync` sont les traits qui identifient une structure comme étant threadsafe ; ce sont des traits de marquage : ils n'ont aucune fonction à implémenter, ils se contente de caractériser le type qui les implémente comme ayant certaines propriétés :
    - `Send` indique qu'on peut transférer sans risque l'ownership du type à un autre thread. Exemple de type non-Send = `Rc` : l'implémentation de Rc n'étant pas threadsafe, envoyer un clone de Rc dans un autre thread va conduire à des race-conditions → pour les éviter au compile-time, Rc n'est pas `Send`
    - `Sync` indique qu'on peut utiliser une référence vers le type de facçon threadsafe :
        > In other words, any type T is Sync if &T (an immutable reference to T) is Send, meaning the reference can be sent safely to another thread
- les types de base du langage implémentent pour la plupart `Send` et `Sync`
- de plus, un type fabriqué à partir de sous-types `Send` et `Sync` sera lui-même `Send` et `Sync`
- du coup, à moins de développer mes propres primitives threadsafes (auquel cas la lecture du rustonomicon est un préalable indispensable), je n'aurais jamais à implémenter `Send` et `Sync` manuellement, j'utiliserais plutôt les primitives threadsafe déjà disponibles dans la stdlib :
    > The Rust standard library provides channels for message passing and smart pointer types, such as Mutex<T> and Arc<T>, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won’t end up with data races or invalid references.
- au passage, la gestion de la concurrence en rust est très peu définie dans les features du langage lui-même, et beaucoup dans la stdlib ou des crates third-party : si on a un besoin de primitives particulières de concurrence, ne pas hésiter à aller regarder la crate qui a la cote pour ce besoin


## Chapitre 17 = Object Oriented Programming Features of Rust

https://doc.rust-lang.org/book/ch17-00-oop.html

> Many competing definitions describe what OOP is, and by some of these definitions Rust is object-oriented, but by others it is not.

^ comme toujours, définir la POO n'est pas simple...

### 17.1. Characteristics of Object-Oriented Languages

https://doc.rust-lang.org/book/ch17-01-what-is-oo.html

Trois caractéristiques souvent associées à la POO :

> - Objects Contain Data and Behavior
> - Encapsulation that Hides Implementation Details
> - Inheritance as a Type System and as Code Sharing


**Objects Contain Data and Behavior**

> Object-oriented programs are made up of objects. An object packages both data and the procedures that operate on that data. The procedures are typically called methods or operations.

^ définition de la POO par le _Gang of Four_

Selon cette définition, rust est un langage orienté objet, puisqu'on peut associer des méthodes aux structs et enums.

**Encapsulation that Hides Implementation Details**

> Another aspect commonly associated with OOP is the idea of encapsulation, which means that the implementation details of an object aren’t accessible to code using that object. Therefore, the only way to interact with an object is through its public API

^ une définition de l'encapsulation.

Selon cette définition, rust est orienté objet puisqu'on peut définir ce qui est public et ce qui est privé dans les structs (et modules).

**Inheritance as a Type System and as Code Sharing**

> Inheritance is a mechanism whereby an object can inherit elements from another object’s definition, thus gaining the parent object’s data and behavior without you having to define them again.

^ une définition de l'héritage.

Selon cette définition, rust n'est pas vraiment un langage orienté objet. Mais si on y regarde de plus près, on a deux raisons d'utiliser l'héritage :

- réutiliser des données ou des comportements de la classe parente
- **polymorphisme** = permettre d'utiliser une classe enfant là où le client attend une classe parente

Rust ne permet pas l'héritage pour réutiliser les données ou le comportement (c'est maintenant considéré comme une mauvaise pratique, _prefer composition over inheritance_) mais rust permet le polymorphisme, par un autre moyen que l'héritage : les traits.

### 17.2. Using Trait Objects That Allow for Values of Different Types

https://doc.rust-lang.org/book/ch17-02-trait-objects.html

Les traits permettent de définir des interfaces à implémenter (ce que d'autres langages font classiquement avec de l'héritage)

**trait object** = un objet qui implémente un trait. (EDIT: en fait, un objet _dynamique_ qui implémente un trait, i.e. un objet inconnu au compile-time, notamment on ne connaît pas sa taille)

> A trait object points to both an instance of a type implementing our specified trait and a table used to look up trait methods on that type at runtime.

^ L'implémentation est proche du C++, avec une v-table.

> We create a trait object by specifying some sort of pointer, such as a & reference or a Box<T> smart pointer, then the dyn keyword, and then specifying the relevant trait.

^ ça correspond au polymorphisme en C++.

**IMPORTANT** NDM : du coup, le même mécanisme (= les traits) permet les deux sortes de polymorphismes du C++ :

- polymorphisme statique = avec les templates (avec des traits rust "classiques")
- polymorphisme dynamique = par héritage, avec un pointeur ou une référence sur une classe parente (avec des traits rust dyn, sur un pointeur)

Du coup, le vocabulaire et les concepts sont différents selon comment on utilise un trait :

- **generic** = un objet (connu au compile-time) qui implémente un trait, cet objet est un **trait bound**, permettant du static dispatch
- **trait object** = un pointeur vers un objet (inconnu au compile-time) qui implémente un trait, permettant du dynamic dispatch

NDM : [cet item de Effective Rust](https://www.lurklurk.org/effective-rust/generics.html) explore la différence entre les deux plus en profondeur, et confirme ma compréhension ; notamment :

> there are two ways to make use of traits: as trait bounds for generics, or in trait objects (...) Rust's generics are roughly equivalent to C++'s templates: they allow the programmer to write code that works for some arbitrary type T, and specific uses of the generic code are generated at compile time – a process known as monomorphization in Rust, and template instantiation in C++. (...) In comparison, trait objects are fat pointers that combine a pointer to the underlying concrete item with a pointer to a vtable that in turn holds function pointers for all of the trait implementation's methods.

^ les deux ont leurs avantages et inconvénients, mais il faut noter qu'une différence importante est qu'un trait object ne peut représenter qu'une unique interface, là où un trait bound peut implémenter plusieurs traits.

> (trait object's) specific purpose is to allow abstraction across common behavior.

^ la raison d'être des traits objects, c'est de permettre une forme de polymorphisme.

> `Box<dyn Draw>` is a trait object; it’s a stand-in for any type inside a Box that implements the Draw trait.

^ modèle mental d'un trait object = un pointeur vers un trait ; notamment, les trait objects sont forcément une forme de pointeur (Box, référence, smart-pointer, etc.).

Un point important, c'est que ça permet des collections d'objets hétérogènes (ce que ne permettent pas les trait-bounds, qui sont certes génériques, mais sur un unique type d'objets), j'ai fait une POC sur le sujet.

Et le truc cool, c'est que les trait objects permettent du dynamic-dispatch, mais avec des vérifications au compile-time que le trait est bien implémenté !

### 17.3. Implementing an Object-Oriented Design Pattern

https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html

Le chapitre montre un exemple d'application où on implémente le _state pattern_ de deux façons différentes, toutes deux valides.

La première façon montre l'utilisation de traits objects, les exemples utilisent plusieurs features de rust, des `Option`, de `Box` et `dyn`, ils sont intéressants.

Notamment, utiiser des traits objects plutôt que des enums pour les states permet d'éviter d'avoir à exhaust tous les variants dans le code appellant.

Intérêt du pattern :

> The methods on Post know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the State trait on the Published struct.

^ le pattern est facile à comprendre et à étendre.

> By implementing the state pattern exactly as it’s defined for object-oriented languages, we’re not taking as full advantage of Rust’s strengths as we could. Let’s look at some changes we can make to the blog crate that can make invalid states and transitions into compile time errors.

^ l'objectif est d'avoir des erreurs de compilation sur les states et transitions invalides.

La suite montre une autre intéressante façon d'obtenir le comportement voulu (et surtout de respecter les contraintes imposées sur les états et leurs transitions) en les exprimant grâce au type-system, de sorte que les situations invalides ne compilent même pas.

Les dernières phrases de conclusion sont intéressantes :

- les trait objects apportent du polymorphisme dynamique, et permettent donc d'implémenter les patterns OOP
- MAIS c'est pas toujours le plus approprié : on peut exprimer ce qu'on veut faire sous forme de types, de sorte que le compilo enforce ce qu'on veut faire (Haskell-style)
- les deux façons de faire sont valides, elles ont des trade-offs différents

## 18. Patterns and Matching

https://doc.rust-lang.org/book/ch18-00-patterns.html

### 18.1. All the Places Patterns Can Be Used

https://doc.rust-lang.org/book/ch18-01-all-the-places-for-patterns.html

Cette page liste tous les endroits où on peut utiliser des patterns :

- `match` (qui est exhaustif = il faut avoir prévu tous les cas possibles)
    - notamment, `_` matche tout mais ne binde rien
- `if let`, qui est un équivalent de match, mais quand on ne s'intéresse qu'à un seul variant
    > The downside of using if let expressions is that the compiler doesn’t check for exhaustiveness, whereas with match expressions it does.
- `while let`, qui boucle tant que le pattern arrive à matcher :
    > Similar in construction to if let, the while let conditional loop allows a while loop to run for as long as a pattern continues to match
- les boucles `for`, qui matchent un pattern (ce qui permet p.ex. de déstructurer des tuples) :
    > In a for loop, the value that directly follows the keyword for is a pattern.
- les `let`statements !
- les function parameters

> patterns don’t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable.

^ attention que même si tous ces constructs utilisent des patterns, ils n'acceptent pas tout à fait les mêmes patterns, c'est l'objet du sous-chapitre suivant.

### 18.2. Refutability: Whether a Pattern Might Fail to Match

https://doc.rust-lang.org/book/ch18-02-refutability.html

> Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable. An example would be x in the statement let x = 5; (...) Patterns that can fail to match for some possible value are refutable. An example would be Some(x) in the expression if let Some(x) = a_value

^ pour un programme donné, il y a deux types de patterns :

- **irrefutable** = parmi toutes les valeurs que le programme peut donner à manger au pattern, le compilo a pu vérifier qu'elles matcheraient toutes : le pattern est garanti de matcher.
- **refutable** = parmi toutes les valeurs que le programme peut donner à manger au pattern, certaines matcheront, d'autres non.

En résumé, un pattern est réfutable s'il a la possibilité de ne pas matcher au runtime ; un pattern est irréfutable s'il matchera dans 100% des cas au runtime.

> Function parameters, let statements, and for loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don’t match.

^ Certains constructs acceptant des patterns n'acceptent QUE de patterns irréfutables.

Note que pour qu'un pattern soit irréfutable, il ne s'agit pas que le pattern matchent toutes les valeurs possibles de l'univers entier : juste qu'il matche toutes les valeurs possibles que le programme pourra lui donner à manger en entrée. J'ai fait une POC sur le sujet.

```rs
let Some(x) = y;
```

^ si le compilo peut prouver que tous les `y` que le programme peut donner à manger au pattern quand on atteint cette ligne seront des `Some`, alors ça va compiler : le pattern est irréfutable. Sinon, ça ne compilera pas car `let` attend un pattern irréfutable.

```rs
if let Some(x) = y;
```

^ ici, ça compilera toujours même si le programme peut donner des `y` à manger au pattern qui ne sont pas des `Some` (et qui ne matcheront donc pas), car `if let` accepte les patterns réfutables.

> match arms must use refutable patterns, except for the last arm, which should match any remaining values with an irrefutable pattern

^ c'est logique, mais les arms d'un bloc `match` utilisent des patterns réfutables (sinon, ils n'auraient pas d'intérêt car on matcherait le premier pattern irréfutable), à l'exception du dernier pattern qui doit faire la voiture poubelle et matcher tout le reste.

### 18.3. Pattern Syntax

https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html

Ce chapitre démontre toute la puissance du pattern matching, avec plein plein d'exemples concrets.

On peut matcher :

- des literals
- deux patterns rassemblés par une clause OR
- en bindant à des variables nommées quand on destructure
- des ranges
- des structs
- des enums

Quelques illustrations :

```rs
match x {
    // Opérateur OR
    1 | 2 => println!("one or two"),

    // range, les deux bornes sont incluses :
    1..=5 => println!("one through five"),
    'a'..='j' => println!("early ASCII letter"),
    // Seuls numeric et chars sont autorisés
}

// Déstructurer une struct :
let Point { x: a, y: b } = p;

// Idem en un peu plus concis, si on utilise les bons noms de fields :
let Point { x, y } = p;

// Plein de trucs en même temps :
let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
```

On peut faire un genre de destructuring partiel pour matcher en vérifiant qu'une partie des champs a une valeur précise, et binder le reste :

```rs
match p {
    Point { x, y: 0 } => println!("On the x axis at {x}"),
    Point { x: 0, y } => println!("On the y axis at {y}"),
    Point { x, y } => {
        println!("On neither axis: ({x}, {y})");
    }
}
```

On peut destructurer sur plusieurs niveaux :

```rs
match msg {
    Message::ChangeColor(Color::Rgb(r, g, b)) => { /* ... */ }
}
```

**Ignoring Values in a Pattern**

La base : `_`

On peut utiliser plusieurs fois `_` dans le même pattern :

```rs
(first, _, third, _, fifth) => { /* ... */ }
```

> Note that there is a subtle difference between using only _ and using a name that starts with an underscore. The syntax `_x` still binds the value to the variable, whereas _ doesn’t bind at all.

^ ça peut avoir un effet dans certains cas, car en bindant, on peut prendre l'ownership.

`..` est en quelque sorte un `_` multiple :

> With values that have many parts, we can use the .. syntax to use specific parts and ignore the rest, avoiding the need to list underscores for each ignored value. 

```rs
let origin = Point { x: 0, y: 0, z: 0 };
match origin {
    Point { x, .. } => println!("x is {}", x),
}
```

Un truc spécial réservé aux clauses `match` : la **match guard** pour ajouter des conditions supplémentaires qui doivent être vérifiées pour que le pattern matche :

```rs
let num = Some(4);

match num {
    Some(x) if x % 2 == 0 => println!("The number {} is even", x),
    Some(x) => println!("The number {} is odd", x),
    None => (),
}
```

**IMPORTANT** : si on utilise une match guard, le compilo ne vérifie plus l'exhaustivité du bloc match !

> The downside of this additional expressiveness is that the compiler doesn't try to check for exhaustiveness when match guard expressions are involved.

Last but not least : pour faire en même temps le match d'une variable avec un pattern ET la capture de sa déstructuration, on utilise l' **operator @** :

```rs
match msg {
    Message::Hello { id: id_variable @ 3..=7, } => /* ... */,
}
```

## 19. Advanced Features

https://doc.rust-lang.org/book/ch19-00-advanced-features.html

### 19.1. Unsafe Rust

https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html

**IMPORTANT** :

- s'il n'y avait qu'une chose à retenir d'unsafe-rust, ce serait l'idée que déclarer quelque chose comme unsafe revient à dire "je m'engage à vérifier moi-même les invariants nécessaires à ce que ce code unsafe ne conduise pas à un undefined-behaviour"
- à chaque fois qu'on écrit du code unsafe, il faut donc s'astreindre à bien comprendre les préconditions du bloc unsafe, et à les vérifier
- du point de vue design, une bonne pratique est de wrapper le couple (vérification des préconditions + utilisation du code unsafe) au sein d'une même fonction, et de n'exposer que cette fonction wrappante qui est toujours safe : ainsi, on n'a pas de risque que le code unsafe soit mal utilisé.
- de plus, une autre bonne pratique est d'ajouter un commentaire pour expliquer pourquoi on a eu besoin d'unsafe
- unsafe rust ne "désactive pas" le borrow-checker ou d'autres vérifications, il nous donne simplement accès à 5 opérations supplémentaires par rapport à safe-rust

----

Unsafe rust est décrit comme un sous langage / un langage différent de safe rust.

Dans un bloc unsafe, toutes les règles habituelles s'appliquent (notamment, le borrow-checker reste actif !), on gagne simplement 5 nouvelles actions qui étaient interdites en safe-rust, les so-called _superpowers_ :

- _Dereference a raw pointer_
- _Call an unsafe function or method_
- _Access or modify a mutable static variable_
- _Implement an unsafe trait_
- _Access fields of unions_

**Dereferencing a Raw Pointer**

```rs
let mut num = 5;

// syntaxe pour créer des raw pointers, immutable et mutable :
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

// pour les déréférencer, il faut être unsafe :
unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

(On peut créer un raw pointer en safe rust : le créer n'est pas spécialement unsafe ; en revanche, on ne peut pas le déréférencer)

**Calling an Unsafe Function or Method**

```rs
unsafe fn dangerous() {}
unsafe {
    dangerous();
}
```

> wrapping unsafe code in a safe function is a common abstraction.

^ pour avoir un bon design, le point important avec le code unsafe est de le wrapper dans une fonction safe. C'est très clair avec leur exemple = reimplémenter nous-même `split_at_mut`, qui splitte un range en deux sous-ranges ; voici un code naïf qui ne marche pas mais qui illustre l'idée :

```rs
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    assert!(mid <= len);
    (&mut values[..mid], &mut values[mid..])
}
```

^ ce code naïf ne peut pas marcher, puisqu'on a besoin de retourner deux références mutables sur le même objet (or, le borrow-checker ne nous autorise à n'en avoir qu'une en même temps). Même si nous humains on sait que c'est safe (car nos deux références mutables pointent certes sur le même range, mais sur des morceaux disjoints), le compilo ne peut pas le voir :

> Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.

^ ce genre de cas où nous humain on sait que c'est safe, mais que le compilo ne le sait pas, c'est le genre de cas où on utilise unsafe rust.

Du coup, l'exemple donné illustre très bien :

1. pourquoi on peut avoir besoin d'unsafe
2. comment et pourquoi appeler une fonction unsafe `slice::from_raw_parts_mut`
3. comment wrapper l'utilisation d'une fonction unsafe dans une API safe (ici, notre "API safe" est une fonction safe)

Le point important, c'est de créer une fonction qui, certes, contient un bloc unsafe, mais qui sera quand même TOUJOURS safe vue de l'extérieur : c'est dans le corps de la fonction qu'elle s'assure que les préconditions nécessaires au bloc unsafe pour ne pas donner d'undefined-behaviour sont respectées, i.e. on s'est assuré "manuellement" que le bloc unsafe était safe.

Ça contraste avec le fait de permettre d'utiliser directement une fonction unsafe : dans ce cas, selon la façon dont le client utilise la fonction unsafe (i.e. de s'il respecte les préconditions rendant safe le bloc unsafe), l'utilisation de la fonction pourra être unsafe (alors qu'avec notre API safe, l'utilisation de la fonction externe était toujours safe).

Autre sujet : lorsqu'on veut utiliser depuis rust une fonction d'une lib dans un autre langage (FFI), on déclare la fonction à appeler dans un bloc `extern "C" { ... }` , qui sera forcément unsafe, vu que le compilo rust n'a pas eu la main sur la fonction.

**Accessing or Modifying a Mutable Static Variable**

En rust, les variables globales sont appelées `static`. Ce sont des références. Seul du code unsafe peut muter une variable globale, car c'est compliqué d'éviter les data-races quand on le fait, donc safe-rust interdit de muter des variables globales.

**Implementing an Unsafe Trait**

Les traits peuvent être déclarés unsafe (et leur implémentation l'est aussi) :

```rs
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
```

> A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify (...) By using unsafe impl, we’re promising that we’ll uphold the invariants that the compiler can’t verify.

^ ici aussi, on retrouve l'idée que déclarer quelque chose comme unsafe revient à dire "je m'engage à vérifier moi-même les invariants nécessaires à ce que ce code unsafe ne conduise pas à de l'undefined-behaviour".

**Accessing Fields of a Union**

Les unions sont peu utilisées en rust : surtout pour interagir avec des unions en C. Comme rust ne peut pas savoir quel "variant" l'union contient, accéder à des fields d'une union est unsafe.

### 19.2 Advanced Traits

https://doc.rust-lang.org/book/ch19-03-advanced-traits.html

**Associated type**

Un associated type associé à un trait est un type "placeholder" dont le trait a besoin pour exprimer les signatures de ses fonctions. P.ex. avec `Iterator` :

```rs
pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

C'est à la structure qui implémente le trait de préciser le type concret du placeholder :

```rs
impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item>
```

Note : ça ressemble au fait de faire un generic sur le trait, mais c'est différend : avec un generic, le trait est generic (et pour une même struct, on pourrait implémenter plusieurs fois le trait, en changeant le type générique). Avec un associated type, le trait n'est pas générique (on ne peut l'implémenter qu'une fois pour un type).


**Default Generic Type Parameters and Operator Overloading**

Quand un trait est générique sur un type, il est possible de donner un type par défaut qui sera utilisé pour les implémentations du trait qui ne souhaitent pas préciser le type concret à utiliser comme generic.

(l'exemple donné utilise l'implémentation du trait `Add` ou au lieu d'ajouter deux types identiques (car le `Rhs` de `Add` a une valeur par défaut = la même que le Lhs), on peut si on le souhaite passer un `Rhs` d'un type différent, et ainsi p.ex. additionner des mètres et des millimètres.

**Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name**

On peut avoir conflit entre une méthode d'un même nom proposée par plusieurs traits (ou par la classe implémentant le trait). Dans ce cas, on qualifie plus finement le nom de la méthode, en appelant la méthode en lui passant explicitement l'instance comme premier paramètre :

```rs
let person = Human;
Pilot::fly(&person);
Wizard::fly(&person);
person.fly();
```

Si le trait demande une méthode statique, qu'on veut utiliser, on n'a pas d'instance à passer en premier paramètre, et il y a alors ambiguïté entre les différentes implémentations du trait. On résout l'ambigüité en castant :

```rs
println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
```

**Using Supertraits to Require One Trait’s Functionality Within Another Trait**

Un trait `T1` peut "dépendre" d'un autre trait `T2`, i.e. exprimer que toute structure qui l'implémente doit également implémenter l'autre trait `T2`.

L'exemple donné = si on veut proposer un trait `OutlinePrint` qui affiche quelque chose avec un détourage, on veut dépendre du fait que ce quelque chose sache déjà s'afficher "tout court", et donc implémente déjà le trait `fmt::Display`.

La syntaxe est :

```rs
trait OutlinePrint: fmt::Display {
    // méthodes de OutlinePrint
}
```

Ici, `Display` est un **supertrait** de `OutlinePrint`.

**Using the Newtype Pattern to Implement External Traits on External Types**

Ce paragraphe est intéressant : pour contourner l'orphan-rule qui dit qu'on ne peut pas implémenter un trait `T` pour une struct `S` si on ne le fait pas dans le même module que `T` ou `S`, on peut implémenter `T` pour un `Newtype(S)` (et même implémenter `Deref` pour manipuler le newtype comme un `S`).

L'exemple donné est d'implémenter `fmt::Display` pour des `Vec<String>`.

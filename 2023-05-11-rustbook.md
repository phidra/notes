# The Rust Programming Language

- **url** = https://doc.rust-lang.org/book/
- **type** = livre de référence sur le langage
- **auteur** = Steve Klabnik and Carol Nichols, with contributions from the Rust Community
- **date de publication** = N/A (le contenu est mis à jour régulièrement)
- **source** = [doc officielle rust](https://doc.rust-lang.org/)
- **tags** = language>rust ; topic>language ; level>beginner

Livre chaudement recommandé par Vivien.

Je n'annote pas tout exhaustivement, je me contente de quelques pointeurs, mots ou concepts clés, citations, et commentaires persos. Je ne prends pas de notes de synthèse (e.g. sur les différentes commandes cargo possibles), je me contente d'annoter au fil des chapitres.

* [The Rust Programming Language](#the-rust-programming-language)
   * [Installation](#installation)
      * [Utilisation avec neovim](#utilisation-avec-neovim)
   * [Chapitre 1 = Getting Started](#chapitre-1--getting-started)
   * [Chapitre 2 = Programming a Guessing Game](#chapitre-2--programming-a-guessing-game)
   * [Chapitre 3 = Common Programming Concepts](#chapitre-3--common-programming-concepts)
   * [Chapitre 4 = Understanding Ownership](#chapitre-4--understanding-ownership)
      * [Chapitre 4.1 = What Is Ownership?](#chapitre-41--what-is-ownership)
      * [Chapitre 4.2 = References and Borrowing](#chapitre-42--references-and-borrowing)
      * [Chapitre 4.3 = The Slice Type](#chapitre-43--the-slice-type)
   * [Chapitre 5 = Using Structs to Structure Related Data](#chapitre-5--using-structs-to-structure-related-data)
      * [Chapitre 5.1 = Defining and Instantiating Structs](#chapitre-51--defining-and-instantiating-structs)
      * [Chapitre 5.2 = An Example Program Using Structs](#chapitre-52--an-example-program-using-structs)
      * [Chapitre 5.3 = Method Syntax](#chapitre-53--method-syntax)
   * [Chapitre 6 = Enums and Pattern Matching](#chapitre-6--enums-and-pattern-matching)
      * [The match Control Flow Construct](#the-match-control-flow-construct)
      * [Concise Control Flow with if let](#concise-control-flow-with-if-let)
   * [Chapitre 7 = Managing Growing Projects with Packages, Crates, and Modules](#chapitre-7--managing-growing-projects-with-packages-crates-and-modules)
   * [Chapitre 8 = Common Collections](#chapitre-8--common-collections)
   * [Chapitre 9 = Error Handling](#chapitre-9--error-handling)
   * [Chapitre 10 = Generic Types, Traits, and Lifetimes](#chapitre-10--generic-types-traits-and-lifetimes)
      * [Chapitre 10.1 = Generic Data Types](#chapitre-101--generic-data-types)
      * [Chapitre 10.2 = Traits: Defining Shared Behavior](#chapitre-102--traits-defining-shared-behavior)
      * [Validating References with Lifetimes](#validating-references-with-lifetimes)
         * [quel problème résout-on grâce aux lifetimes ?](#quel-problème-résout-on-grâce-aux-lifetimes-)
   * [Appendix D - Useful Development Tools](#appendix-d---useful-development-tools)

## Installation

J'ai suivi la recommandation officielle :

```sh
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# [...]

rustc --version
# rustc 1.69.0 (84c898d65 2023-04-16)
```

J'ai conservé les chemins par défaut, ils sont indiqués dans la sortie de l'installation :

<details>
  <summary>Cliquer pour voir l'output</summary>

```
info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust
programming language, and its package manager, Cargo.

Rustup metadata and toolchains will be installed into the Rustup
home directory, located at:

  /home/myself/.rustup

This can be modified with the RUSTUP_HOME environment variable.

The Cargo home directory is located at:

  /home/myself/.cargo

This can be modified with the CARGO_HOME environment variable.

The cargo, rustc, rustup and other commands will be added to
Cargo's bin directory, located at:

  /home/myself/.cargo/bin

This path will then be added to your PATH environment variable by
modifying the profile files located at:

  /home/myself/.profile
  /home/myself/.bashrc
  /home/myself/.zshenv

You can uninstall at any time with rustup self uninstall and
these changes will be reverted.

Current installation options:


   default host triple: x86_64-unknown-linux-gnu
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes
```

</details>

### Utilisation avec neovim

J'utilise [rust-tools](https://github.com/simrat39/rust-tools.nvim#setup).

Dans le `.vimrc` (

```lua
require('rust-tools').setup{
   on_attach = on_attach,
   flags = lsp_flags,
}
```

Attention que le `require` est un poil différent des autres lspconfig, ce qui est rappelé explicitement dans [la doc](https://github.com/simrat39/rust-tools.nvim#setup) :

> This plugin automatically sets up nvim-lspconfig for rust_analyzer for you, so don't do that manually, as it causes conflicts.

(on trouve aussi le setup de rust-analyzer, légèrement différent, [ici](https://rust-analyzer.github.io/manual.html#nvim-lsp)).

Chez moi, après une fresh installation de rust avec rustup, `rust-analyzer` n'est pas utilisable :

- sous neovim, quand je tape `:LspLog` :
    ```
    [START][2023-05-12 11:48:00] LSP logging initiated
    [START][2023-05-12 11:48:45] LSP logging initiated
    [ERROR][2023-05-12 11:48:46] .../vim/lsp/rpc.lua:420▶   "rpc"▶  "rust-analyzer"▶"stderr"▶   "error: 'rust-analyzer' is not installed for the toolchain 'stable-x86_64-unknown-linux-gnu'\n"
    ```
- et effectivement, dans un terminal, le binaire `rust-analyzer` a beau exister, il n'est pas utilisable :
    ```
    rust-analyzer --version
    # error: 'rust-analyzer' is not installed for the toolchain 'stable-x86_64-unknown-linux-gnu'
    ```

Du coup, je suis [la doc](https://rust-analyzer.github.io/manual.html#rust-analyzer-language-server-binary) de `rust-analyzer` pour l'installer :

```sh
curl -L https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - > ~/.local/bin/rust-analyzer
chmod +x ~/.local/bin/rust-analyzer
```

Mais comme j'ai maintenant deux versions concurrentes de `rust-analyzer`, il faut que je désactive celle qui ne marche pas → ça fonctionne :

```sh
mv ~/.cargo/bin/rust-analyzer ~/.cargo/bin/REMOVED_rust-analyzer

rust-analyzer --version
# rust-analyzer 0.3.1506-standalone
```

Note : on dirait que `rust-analyzer` nécessite un projet cargo pour fonctionner, et qu'il ne peut pas compiler un code-source standalone :

```
[ERROR][2023-05-12 11:58:39] .../vim/lsp/rpc.lua:420▶   "rpc"▶  "rust-analyzer"▶"stderr"▶   '[ERROR rust_analyzer::config] failed to find any projects in [AbsPathBuf("/path/to/my/projects")]\n'
[ERROR][2023-05-12 11:58:39] .../vim/lsp/rpc.lua:420▶   "rpc"▶  "rust-analyzer"▶"stderr"▶   "[ERROR rust_analyzer::main_loop] FetchWorkspaceError:\nrust-analyzer failed to discover workspace\n"
```

## Chapitre 1 = Getting Started

https://doc.rust-lang.org/book/ch01-00-getting-started.html

`rustup` = tool pour installer et maintenir rust.

Il faut un linker, voire un C compiler.

`rustc` = le compilateur rust.

Dans l'Appendix D :

- `rustfmt` = formatter
- `rustfix` = fixeur d'erreurs
- `rust-analyzer` = LSP

Macro = "fonction" suffixée par `!`

`cargo` = à la fois _build-system_ et _package-manager_ :

 ```
cargo new
cargo build (--release)
cargo run
cargo check
```

Le build par défaut est en mode `debug` (donc l'exécutable buildé va dans `target/debug/`)

`cargo.lock` = versions pinnées des dépendances du projet.

Un `crate` (qui se traduit en "caisse") est un package.

## Chapitre 2 = Programming a Guessing Game

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html

`associated functions` d'un type donné.

Syntaxe : préfixe `&` = référence

Les références sont immutables par défaut, il faut `&mut myref` si on veut des références mutables.

`Result` est un enum qui vaut soit `Ok` soit `Error`

`expect()` gère les deus valeurs possibles de `Result` :

- si on reçoit un `Ok`, il renvoie la valeur du `Ok`
- si on reçoit une `Error`, il crashe

Si le code-source ne traite que le `Ok`, le programme compile quand même, mais avec un warning.

Quand on utilise la macro `println!`, les strings peuvent interpréter des templates (comme les f-strings).

> Rust doesn’t yet include random number functionality in its standard library. However, the Rust team does provide a rand crate with said functionality.

https://crates.io = le registre officiel des crates, un genre d'équivalent de pypi.


Quand on précise des versions dans `Cargo.toml`, même si la version `0.8.5` précisée veut en fait dire `^0.8.5` (et que donc la version `O.8.6` sera préférée à la `0.8.5` quand elle sortira), une fois que `Cargo.lock` a été généré avec la `0.8.5`, le projet n'utilisera plus que cette version, même si la `0.8.6` sort après coup. (et je suppose qu'il faut supprimer `Cargo.lock`, ou utiliser une commande (EDIT : `cargo update`) pour le mettre à jour pour passer explicitement à la `0.8.6`)

> When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the Cargo.lock file. When you build your project in the future, Cargo will see that the Cargo.lock file exists and will use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at 0.8.5 until you explicitly upgrade, thanks to the Cargo.lock file. Because the Cargo.lock file is important for reproducible builds, it’s often checked into source control with the rest of the code in your project.
>
> When you do want to update a crate, Cargo provides the command update, which will ignore the Cargo.lock file and figure out all the latest versions that fit your specifications in Cargo.toml.

Sur les traits :

> The Rng trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods.

L'expression `start..=end` est une range-expression qui inclut `start` et `end`.

> running the cargo doc --open command will build documentation provided by all your dependencies locally and open it in your browser

Un exemple de pattern-matching (pour comparer le nombre entré au nombre recherché) est donné :

> A match expression is made up of arms. An arm consists of a pattern to match against, and the code that should be run if the value given to match fits that arm’s pattern. (...)
>
> Patterns and the match construct are powerful Rust features: they let you express a variety of situations your code might encounter and they make sure you handle them all.

On voit que le langage a été pensé par des devs :

> Shadowing lets us reuse the guess variable name rather than forcing us to create two unique variables, such as guess_str and guess, for example. 

Quand on convertit une string en int avec `parse()`, c'est l'un des cas où il faut préciser explicitement le type (par exemple pour savoir dans quel type d'entier placer la string parsée).

Au lieu de `expect()` un `Result`, on peut faire un `match` pour traiter les deux cas :

```rs
let guess: u32 = match guess.trim().parse() {
   Ok(num) => num,
   Err(_) => continue,
};
```

----

Mes notes en refaisant le guessing game moi-même :

- il y a deux types de strings, des literal et des string objects
- `expect()` ne semble pas autoriser un string object, uniquement un string literal
- avec les rust-tools dans neovim, il y a un truc SUPER cool, c'est qu'il indique les types de chaque ligne

## Chapitre 3 = Common Programming Concepts

https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html

Variables immutables par défaut (pas encore clair si c'est la référence qui est constante, ou l'objet).

`let` vs `let mut`

`const` = constante connue au compile time (donc plus fort qu'une variable non-mutable)

Répéter `let` avec le même nom de variable pour shadower une variable par une autre.

4 primary scalar types = `int` + `float` + `bool` + `char`

Le flottant par défaut est `f64`, soit l'équivalent d'un `double`.

`isize` / `usize`= équivalents de `size_t` = de quoi indexer un conteneur, architecture-dépendent car 64 bit ou 32 bit :

> The primary situation in which you’d use isize or usize is when indexing some sort of collection.

Comment rust réagit en cas d'overflow au runtime ?

- En mode debug, il panic
- En mode release, il complémente à deux

(note que l'overflow peut dépendre d'un I/O utilisateur, e.g. si on additionne deux entiers que l'utilisateur a entrés → on peut ne pas le connaître au compile-time)

Les `char` sont des points de code unicode (et je suppose que les strings sont des tableaux de `char` ; EDIT : non, a priori, ce sont des bytestrings encodées en UTF-8).

`tuple` + unpacking (de son vrai nom : _destructuring_)

Syntaxe : indexer un tuple se fait avec un `.` : `my_tuple.2`

Bizarrement, le tuple vide a un nom = `unit`.

Array = même type + longueur fixe (c'est l'équivalent des arrays C) vs. vector (le distinguo semble similaire à celui du C++).

> Arrays are useful when you want your data allocated on the stack rather than the heap (...) or when you want to ensure you always have a fixed number of elements.

Indexer un array se fait comme habituellement = avec des crochets : `my_array[2]`

L'indexing d'un array peut échouer au runtime (mais au lieu d'aller bêtement accéder à la mémoire invalide, et de segfault dans le meilleur des cas, rust va dynamiquement checker la bound et panic si besoin). C'est au runtime que le check a lieu, et comme l'index peut être entré en I/O au runtime, on ne peut pas le savoir au compile-time :

> When you attempt to access an element using indexing, Rust will check that the index you’ve specified is less than the array length. If the index is greater than or equal to the length, Rust will panic. This check has to happen at runtime, especially in this case, because the compiler can’t possibly know what value a user will enter when they run the code later.
>
> This is an example of Rust’s memory safety principles in action. In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed. Rust protects you against this.

Syntaxe : keyword pour définir des fonctions : `fn`

Les expressions ont l'air plus importantes en rust que dans d'autres langages :

> - Statements are instructions that perform some action and do not return a value.
> - Expressions evaluate to a resultant value. Let’s look at some examples.

Si une fonction se termine par une expression (sans `;` final ! Sinon ce n'est plus une expression mais un statement), alors la fonction retourne la valeur de cette expression.

Syntaxe : un grand bloc entre accolades est une expression.

> You can return early from a function by using the return keyword and specifying a value, but most functions return the last expression implicitly.

Les fonctions qui ne retournent rien (soit explicitement avec un `return` vide, soit implicitement via leur dernière expression) renvoient alors `unit` = le tuple vide.

Syntaxe : les `if` sont sans parenthèses.

Les `if` n'acceptent que des bools (pas de cast implicite d'une expression en bool, ce qui est une bonne chose IMO).

La syntaxe de l'opérateur ternaire est plutôt lisible : `let number = if condition { 5 } else { 6 };`

Syntaxe : `loop` pour remplacer `while true` (et elle peut retourner une expression !).

On peut labelliser les loops pour choisir à laquelle s'applique un `break` ou `continue`.

La boucle `for` est comme en python : elle boucle sur les éléments d'un itérable (again : une bonne chose).

## Chapitre 4 = Understanding Ownership

https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html

> [Ownership] enables Rust to make memory safety guarantees without needing a garbage collector

### Chapitre 4.1 = What Is Ownership?

https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html

Les règles d'ownership sont vérifiées au compile-time, pas au runtime (donc pas de ralentissement au runtime).

> Because ownership is a new concept for many programmers, it does take some time to get used to.

^ sans doute le célèbre combat contre le borrow-checker

Le résumé de stack vs. heap est très bien écrit ; morceaux choisis :

> Both the stack and the heap are parts of memory available to your code to use at runtime, but they are structured in different ways.
>
> The stack stores values in the order it gets them and removes the values in the opposite order. [...] All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.
>
> The heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. [...] Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.
>
> Pushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation. Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. 
>
> [...] knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does

^ Cette dernière phrase est cruciale : l'unique objectif de la gestion de la mémoire (que ce soit par garbage-collection, par gestion manuelle ou par l'approche retenue par rust = l'ownership) est de gérer les données du heap (notamment d'éviter les use-after-free et les double-free), c'est le problème qu'on essaye de résoudre. (plus bas, c'est ce qui explique qu'il n'y a pas de notion d'ownership pour `let y = x;` avec des entiers, qui n'ont aucune donnée sur le heap, mais qu'il y en a pour les strings).

Le principe de l'ownership est proche des `unique_ptr` (que je me plais à voir comme "manipuler des heap-allocated data comme si elles étaient sur la stack") :

> - Each value in Rust has an owner.
> - There can only be one owner at a time.
> - When the owner goes out of scope, the value will be dropped.

La page prend l'exemple de la class `String` pour les explications :

> This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time.

Avec les string literal, la variable pointe vers une valeur hardcodée dans le programme (NdM : sans doute dans le segment RO du process ; EDIT = confirmé un peu plus bas = _In the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable_).

Création d'un String object à partir d'un literal :

```rs
let s = String::from("hello");
```

En deux mots, rust a du RAII built-in dans le langage (`drop()` du trait `Drop` est appelée automatiquement lorsqu'une variable arrive en fin de vie) ; so far so good, les choses deviennent compliquées quand plusieurs personnes veulent accéder à la même zone mémoire :

> the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we’ve allocated on the heap

[Ce chapitre](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move) donne des éléments de réponse à une question que je me posais = est-ce que les variables sont des références ou des objets. Dit autrement, si je fais `let y = x`, ai-je deux OBJETS (y qui est une copie de x) ou ai-je deux RÉFÉRENCES vers le même objet ? Dans le cas des entiers, il y a copie ; dans le cas des strings, il y a move (i.e. les deux strings ont utilisé vers le même buffer). Du coup, j'en déduis que le comportement est similaire au C++ = copie, avec le twist lié à l'ownership.

L'exemple est bien parlant :

```rs
let s1 = String::from("hello");
let s2 = s1;
```

La copie a invalidé la référence vers la string copiée (la deuxième string a pris l'ownership du buffer : le buffer a été _moved_).

> Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance.

^ il faut `x.clone()` explicitement si on veut deep-copy.

Pour les types qui ne gèrent pas de données sur le heap, la copie peut être deep sans surcoût :

> there’s no difference between deep and shallow copying here

Pour créer ses types custom qui sont copiables sans surcoût, on les annote avec le trait `Copy` (incompatible avec le trait `Drop`).

> Rust has a special annotation called the Copy trait that we can place on types that are stored on the stack, as integers are (...). If a type implements the Copy trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable.

Le point déroutant = le passage d'arguments aux fonctions move (ou copy, selon le type) tout comme l'assignation dans notre exemple précédent :

> Passing a variable to a function will move or copy, just as assignment does

Dit autrement, à moins que le type soit trivialement copiable, passer une variable à une fonction est suffisant pour la détruire (vu qu'elle est move dans la fonction, et sera détruite quand on sortira du scope de la fonction).

Le comportement fonctionne aussi dans l'autre sens = lorsqu'une fonction `return` une variable, elle est moved ! En résumé, sans précaution particulière, les fonctions prennent et rendent l'ownership.

(dans les exemples qui sont donnés, beaucoup de variables se retrouvent donc dans des états similaires au `moved-from` du C++)

### Chapitre 4.2 = References and Borrowing

https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html

> Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference

Syntaxe : on préfixe les références par `&`, aussi bien pour les variables que pour les types :

```rs
let s1 = String::from("hello");
let len = calculate_length(&s1);

// (...)
fn calculate_length(s: &String) -> usize {
```

Les références sont non-owning (quand la référence arrive en fin de scope, on ne libère aucune donnée sur le heap).

> We call the action of creating a reference **borrowing**.

Les références sont immutables par défaut, il faut `mut` une référence qu'on veut pouvoir muter. S'il existe une référence mutable en vie, aucune autre référence (peu importe qu'elle soit mutable ou immutable !) ne peut exister :

> Mutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value.

L'objectif est d'éviter des data-race, où un thread mute une variable pendant qu'un autre thread la lit.

De façon un peu contre-intuitive, le scope des références ne dure pas jusqu'à la fin du bloc, mais uniquement jusqu'à la ligne de sa dernière utilisation ; on peut donc créer une référence mutable juste après la dernière utilisation d'une référence immutable, elles ne se marcheront pas sur les pieds.

Il est impossible de créer une dangling-reference en rust.

Le résumé :

> At any given time, you can have either one mutable reference or any number of immutable references.

### Chapitre 4.3 = The Slice Type

https://doc.rust-lang.org/book/ch04-03-slices.html

NDM : "j'ai l'ownership de cet objet", ça veut dire "c'est moi qui suis responsable de libérer la mémoire de cet objet (et je le ferai automatiquement quand j'arriverai en fin de vie)"

Syntaxe : `let myslice = &s[4..8];`

Les slices semblent être des équivalents des `std::string_view` = un couple "pointeur vers un item d'un array + nombre d'éléments".

Un slice est une forme de référence → le truc cool par rapport aux string views : comme le slice est une référence et que rust empêche d'avoir une dangling référence, le slice est intrinsèquement couplé à la string = on ne peut pas invalider un slice par erreur. Au final, l'exemple qu'ils donnent en utilisant les slices est une bonne illustration des erreurs que le borrow-checker permet d'empêcher.

Bizarrement, le type d'un slice est `&str`.


NDM : au sujet de l'ownership, tout tient au fait que les références mutables sont exclusives, i.e. si on a une référence mutable, on ne peut pas avoir d'autre référence (mutable ou immutable) en vie en même temps. Or, un slice est une référence immutable et l'action de clear la string nécessite une référence mutable (pour muter la string) → on ne pourra donc pas clear une String tant qu'il existe un slice (qui est une référence immutable) dessus, ce qui empêche donc d'invalider par erreur un slice existant. Plus généralement, une bonne vision est de considérer que pour muter un objet (y compris via une de ses méthodes) on utilise une référence mutable dessus, ce qui interdit l'existence par ailleurs d'une référence, même immutable.

Note : si une fonction attend un slice (`&str`) en argument, elle acceptera certes des slices, mais également des `String` objects (considérés comme un slice "complet"), ou même des string literals (qui sont des slices du binaire du programme).

Les slices ne sont pas spécifiques aux strings : `&[i32]` est le type d'un slice vers un tableau d'entiers.

> The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.

## Chapitre 5 = Using Structs to Structure Related Data

https://doc.rust-lang.org/book/ch05-00-structs.html


### Chapitre 5.1 = Defining and Instantiating Structs

https://doc.rust-lang.org/book/ch05-01-defining-structs.html

La syntaxe pour instancier une struct est un poil bizarre (mais avec l'habitude, je m'y ferai sans souci).

Il y a une syntaxe pour instancier une struct à partir d'une autre (ce qui laisse donc cette dernière dans un état invalide = moved-from ; à moins que les champs clonés soient trivialement copiables) en ne modifiant que certains fields.

`tuple structs` = tuples nommés (distincts les uns des autres, même si les types sous-jacents sont identiques), c'est un moyen de créer des types custom un chouïa plus légers que de faire des structs.

> Each struct you define is its own type, even though the fields within the struct might have the same types.

`unit-like structs` = structs "vides", i.e. sans aucun field.

> In the User struct definition in Listing 5-1, we used the owned String type rather than the &str string slice type. This is a deliberate choice because we want each instance of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.

^ une différence conceptuelle importante entre `String` et `&str` :

- les slices sont des références donc non-owning : quand le slice arrive en fin de vie, le texte n'est pas détruit
- alors que la `String` est owning : quand la `String` arrive en fin de vie, son texte est détruit

Apparemment, pour qu'une struct ait un field qui soit une référence vers quelque chose, il faut une feature supplémentaire = les `lifetimes`.

### Chapitre 5.2 = An Example Program Using Structs

https://doc.rust-lang.org/book/ch05-02-example-structs.html

Pour le moment, les structs ne sont présentées que comme des tuples permettant de nommer les fields.

Ndm : en rust, "prendre une référence sur un objet" se nomme "borrow un objet" (par opposition à "take it's ownership")

Quelques syntaxes utiles au passage en vrac :

```
#[derive(Debug)]
{:#?}
{:?}
dbg!
```

### Chapitre 5.3 = Method Syntax

https://doc.rust-lang.org/book/ch05-03-method-syntax.html

> To define the function within the context of Rectangle, we start an impl (implementation) block for Rectangle. Everything within this impl block will be associated with the Rectangle type.

^ C'est assez marrant en terme de syntaxe (mais au final pas beaucoup plus qu'en cpp) : la définition de la struct et de ses membres est séparée du bloc impl.

> In the signature for area, we use &self instead of rectangle: &Rectangle. The &self is actually short for self: &Self. Within an impl block, the type Self is an alias for the type that the impl block is for

^ Une méthode prend `&self` comme premier argument.

On peut avoir des properties comme en python pour implémenter des getters.

Rust infère l'objet à partir duquel on appelle une méthode, donc il n'y a qu'un unique opérateur `.`

> All functions defined within an impl block are called associated functions because they’re associated with the type named after the impl. We can define associated functions that don’t have self as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with.

^ équivalents des `staticmethod`...

> Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct. These are often called new, but new isn’t a special name and isn’t built into the language. 

^ ... ou des constructeurs !

Si besoin (en l'occurrence, pour implémenter des traits), on peut avoir plusieurs blocs impl pour une même struct.


## Chapitre 6 = Enums and Pattern Matching

> Enums allow you to define a type by enumerating its possible variants.

Exemples d'enum des adresses IP : il n'y a que deux possibilités = IPV4 ou IPV6.

Les variants des enums peuvent stocker des données :

```rs
enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }
```

Les variants des enums peuvent même être des structs, ou même d'autres enums.

On peut définir des méthodes d'enum dans des blocs impl !

Dans la suite, il prend l'exemple des `Option`, qui remplacent la valeur `Null` (ou `None`) que rust n'a pas, ce qui évite à chaque variable de pouvoir être nulle (ce qui évite la situation qu'on a p.ex. en C++, où un pointeur peut soit pointer soit sur un `T` valide, soit être un pointeur nul ; dit autrement, les pointeurs C++ sont obligatoirement des Optional).

À la place, on exprime explicitement avec `Option` les variables qui peuvent être nulles (e.g. le retour d'une fonction renvoyant le premier élément d'une liste va renvoyer `None` si la liste est vide) et ce qu'on y gagne de très important, c'est que toute variable qui n'est pas une `Option` ne peut pas être nulle, elle est forcément un `T` valide !

C'est exprimé plus succintement plus loin : `Option<T>` et `T` sont des types différents, on ne peut pas utiliser un `Option<T>` là où un `T` est attendu.

> Eliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value Option<T>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an Option<T>, you can safely assume that the value isn’t null.
>
> In general, in order to use an Option<T> value, you want to have code that will handle each variant. You want some code that will run only when you have a Some(T) value, and this code is allowed to use the inner T. You want some other code to run only if you have a None value, and that code doesn’t have a T value available. The match expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has.

La suite présente le pattern matching.

### The match Control Flow Construct

> Rust has an extremely powerful control flow construct called match that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.

C'est le pattern matching usuel. Attention, les matchs sont traitées dans l'ordre.

Les possibilités de match sont des **arms**, avec un pattern à gauche, et du code à droite (qui peut se passer de curly bracket `{...}` si le code est simple, ou les utiliser sinon)

> Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.

^ On peut binder un pattern à une valeur, pour l'utiliser dans le code de l'arm.

Un cas fréquent est `Option`, avec deux arms possibles : `None` et `Some(x)` , ce dernier cas bindant à `x` le contenu de l'`Option` :

```rs
match my_option {
    Some(x) => println!("here is the valid value: {x}"),
    None    => println!("there is no value"),
}
```

> Matches in Rust are exhaustive: we must exhaust every last possibility in order for the code to be valid

^ l'intérêt = le compilateur nous force à avoir prévu le code pour traiter _toutes_ les possibilités, sinon ça ne compile pas.

On peut définir un pattern catchall, en définissant une unique variable comme dernier match : elle attrapera tous les cas non traités (et si on n'utilise pas cette variable bindée, on peut l'appeler `_`) (et si on veut ne rien faire, on retourne un tuple vide = des parenthèses vides). Un catchall final qui ne fait rien s'écrit donc :

```rs
_ => ()
```

### Concise Control Flow with if let

`if let` permet en quelque sorte de convertir un bloc `match` en bloc `if`.

Dans certains cas (par exemple quand on est forcés de remplir tout un tas d'arms vides pour un bloc match), ça permet une syntaxe plus concise.

## Chapitre 7 = Managing Growing Projects with Packages, Crates, and Modules

https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

Je n'annote pas (car mieux vaut construire ma compréhension de l'organisation du code sur de petits projets), mais ce chapitre décrit l'organisation du code :

> As a project grows, you should organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques.

## Chapitre 8 = Common Collections

https://doc.rust-lang.org/book/ch08-00-common-collections.html

Description de `Vec`, `String` et `HashMap`.

Ici aussi, inutile d'annoter, mieux vaut pratiquer.

À noter que le [sous-chapitre sur les strings](https://doc.rust-lang.org/book/ch08-02-strings.html) détaille la façon dont rust gère les chaînes de caractères, et notamment la différence entre byte (`u8`), point de code (scalar value), et "letter" (grapheme clusters).

## Chapitre 9 = Error Handling

https://doc.rust-lang.org/book/ch09-00-error-handling.html

Chapitre intéressant sur la gestion d'erreur.

Différence entre :

- les **recoverable errors** = sur lesquelles on peut agir
- les **unrecoverable errors** = on n'a rien de plus d'intelligent à faire que de planter

Les premières renvoient un `Result<T, E>`  ; avec notamment un pattern très utile = l'opérateur `?` qui permet de propager les erreurs.

Les secondes utilisent la macro `panic!`, éventuellement indirectement via `unwrap` ou `expect`.

Concernant l'opérateur `?`, en deux mots, suffixer une variable de type `Result` par l'opérateur `?` dit "utilise ce result comme s'il n'y avait pas eu d'erreur, et si jamais il y a eu une erreur, fais un `return` early avec l'erreur en question".

Les exemples avec et sans l'opérateur `?` sont très illustratifs de la concision qu'on y gagne :

```sh
// SANS = on a beaucoup de cas Err à traiter, ça pollue le code :
fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");
    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };
    let mut username = String::new();
    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => return Err(e),
    }
}


// AVEC = le code est beaucoup plus clair :
fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

À noter : obviously, il faut que le type de retour de la fonction à l'intérieur de laquelle on utilise `?` soit compatible, i.e. qu'elle retourne un `Result<T, E>`.

## Chapitre 10 = Generic Types, Traits, and Lifetimes

https://doc.rust-lang.org/book/ch10-00-generics.html

Fonctions, structs et enum peuvent être génériques (équivalent des templates en C++).

### Chapitre 10.1 = Generic Data Types

https://doc.rust-lang.org/book/ch10-01-syntax.html

Classiquement, on peut implémenter des méthodes génériques.

Plus surprenant, on peut définir une méthode qui n'existe que pour une spécialisation particulière d'une structure (NDM : si cette méthode est publique, c'est un peu bizarre car deux spécialisations différentes d'un même généric n'auront pas la même interface... Mais bon, c'est pas si différent que le nominal subtyping où on hérite d'une interface tout en ayant la possibilité d'ajouter des méthodes propres à la classe fille).

L'éventuel type générique du bloc `impl<T>` indique que l'implémentation porte sur toutes les spécialisations. Si on n'en précise pas, c'est que l'implémentation porte sur une spécialisation particulière :

```rs
// l'implémentation sera partagée par toutes les spécialisations du generic Point :
impl<T> Point<T> {

// l'implémentation est propre à la spécialisation du Point pour les f32 :
impl Point<f32> {
```

Le compilateur rust fonctionne comme en cpp : le généric est instancié à la compilation. Du coup il n'y a pas de runtime cost aux generics, qui sont compilés tout comme si on avait écrit les différentes spécialisations à la main.

### Chapitre 10.2 = Traits: Defining Shared Behavior

https://doc.rust-lang.org/book/ch10-02-traits.html#traits-defining-shared-behavior

> Traits are similar to a feature often called interfaces in other languages, although with some differences.

^ les traits permettent de définir des comportements qui seront partagés par plusieurs types , un peu comme des interfaces implémentées par différentes classes.

```rs
pub trait Summary {
    fn summarize(&self) -> String;
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
```

NDM = on dirait qu'on peut étendre des third-party classes, c'est à dire leur ajouter des comportements a posteriori, ce qui est un peu contre-intuitif vu qu'on ne peut plus connaître l'interface définitive d'une classe.

> Other crates that depend on the aggregator crate can also bring the Summary trait into scope to implement Summary on their own types

^ quand je code une crate, je peux importer un trait d'une autre crate pour que mes propres classes puissent l'implémenter.

> One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate.

^ ceci et les exemples qui suivent montrent que c'est en fait logique :

- on peut ajouter à ses propres classes des comportements définis ailleurs (conceptuellement, c'est similaire à ce que notre classe hérite d'une third-party interface, ou se conforme à un third-party structural subtyping défini)
- on peut ajouter ses propres comportement à une third-party classe (conceptuellement, c'est proche du fait de créer une classe dérivée de la third-party class, voire à définir un C++-trait pour cette classe)
- mais on ne peut pas ajouter des comportements externes à des classes externes, sinon deux personnes différentes pourrait créer du code incompatible :

> This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.

Autre point auquel je ne suis pas habitué : pour utiliser une classe selon cette interface, il faut importer non seulement la classe, mais aussi le trait.

> Implementing a trait on a type is similar to implementing regular methods. The difference is that after impl, we put the trait name we want to implement, then use the for keyword, and then specify the name of the type we want to implement the trait for

^ la syntaxe pour implémenter un trait et une méthode est proche (ce qui est logique).

En implémentant un body au trait, ça fournit une implémentation par défaut.

Syntaxe pour une fonction acceptant en argument "n'importe quoi qui implémente le trait `Summary`" :

```rs
// Raccourci :
fn notify(item: &impl Summary) {
    // ...
}

// Version longue = trait bound :
fn notify<T: Summary>(item: &T) {
    // ...
}
```

Une fonction peut même exprimer qu'elle nécessite en argument un type qui implémente plusieurs traits :

```rs
fn notify(item: &(impl Summary + Display)) {
}

fn notify<T: Summary + Display>(item: &T) {
}
```

Enfin, il y a une troisième syntaxe plus verbeuse, mais plus explicite et claire :

```rs
fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{ }
```

Similairement, une fonction peut retourner un type implémentant un trait :

```rs
fn returns_summarizable() -> impl Summary {
```

On peut définir une implémentation conditionnelle d'une fonction générique uniquement pour certains types = ceux qui implémentent un trait.

Dans le même genre, on peut implémenter un trait pour certains types = tous les types qui implémentent eux même un (autre) trait :

> We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called blanket implementations and are extensively used in the Rust standard library. For example, the standard library implements the ToString trait on any type that implements the Display trait. 

### Validating References with Lifetimes

https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html

Spoiler alert : c'est un gros morceau.

> lifetimes ensure that references are valid as long as we need them to be.

^ ~~les lifetimes maintiennent les références en vie~~ EDIT : non, les lifetimes ne modifient pas la durée de vie des références, ce ne sont que des annotations permettant au borrow-checker de faire son boulot = de vérifier si toutes les références utilisées sont bien en vie = éviter une use-after-free.

> every reference in Rust has a lifetime, which is the scope for which that reference is valid.

^ toutes les références ont des lifetimes ...

> Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We only must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways

^ ... mais la plupart du temps, la lifetimes d'une référence est implicite, on ne doit la préciser que quand elle ne peut pas être inférée.

> Annotating lifetimes is not even a concept most other programming languages have, so this is going to feel unfamiliar.

^ _I brace myself_

Le cas d'exemple pour illustrer les lifetimes :

```rs
fn main() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

^ ce code ne compile pas, et le message d'erreur est clair :

```
`x` dropped here while still borrowed
```

^ au moment où `x` arrive en fin de vie (à la fin du scope intérieur), l'objet `x` (= l'entier 5) va être détruit, or `x` est toujours borrowed par `r` ! Du coup pour éviter un use-after-free, ça ne compile pas.

> So how does Rust determine that this code is invalid? It uses a borrow checker.

^ c'est le rôle du fameux borrow-checker que de vérifier qu'au moment où une variable arrive en fin de vie, il n'existe plus de référence (= de borrow) dessus.

> The Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid.

^ le métier du borrow-checker est de confirmer que tous les références sont valides.

Here, we’ve annotated the lifetime of r with 'a and the lifetime of x with 'b.

^ au moins dans la doc, on parle des lifetimes comme des variables, c'est rigolo (mais c'est vrai que la lifetime a bien un nom de variable, donc c'est logique).

Syntaxe : les lifetimes semblent préfixées par `'`

#### quel problème résout-on grâce aux lifetimes ?

```rs
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

^ l'exemple donné en fil rouge est clair et concis : une fonction `longest` acceptant deux string slices en input (donc des références), et retournant une string slice en output, pointant vers une des deux slices d'input = la plus longue.

> the return type needs a generic lifetime parameter on it because Rust can’t tell whether the reference being returned refers to x or y

^ Si on n'utilise pas les lifetimes, ça ne compile pas : le compilateur rust voit bien qu'on retourne soit une référence vers `x`, soit une référence vers `y`, mais il ne sait pas sur lequel des deux on retourne une référence, donc il ne connaît pas précisément la durée de vie de la référence en output (et ne peut donc pas vérifier par la suite qu'elle n'est pas utilisée après que l'objet référencé soit détruit).

NDM : sans encore avoir lu la suite, je suppose que le fait de ne pas savoir sur quelle référence le retour pointe est problématique, car ça empêche le borrow-checker de faire son taf : quid si l'une des deux références input arrive en fin de vie ?

> we can’t look at the scopes as we did (...) to determine whether the reference we return will always be valid. The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of x and y relate to the lifetime of the return value. To fix this error, we’ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.

^ Indeed, c'était bien l'idée : les lifetimes permettent de donner au borrow-checker les infos liant le cycle de vie des inputs et de l'output.

NDM : on aurait pu proposer que le borrow-checker soit conservateur, et traite la référence en output de façon pessimiste (en lui donnant la durée de vie de la pire des deux références input), mais :

- c'est inutilement pessimiste, donc
- ça peut empêcher d'implémenter certaines fonctions
- de toute façon, c'est faire un truc implicite derrière le dos de l'utilisateur : mieux vaut plutôt lui faire préciser ce qu'il veut.

> Lifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.

^ on n'utilise pas les lifetimes pour MODIFIER la durée de vie de références, mais pour connaître la durée de vie d'une référence (ici, la référence retournée en output) à partir de la durées de vie d'autres références (ici, les références acceptées en input).

Syntaxe :

```rs
&'a i32
&'a mut i32
```

> One lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other

^ histoire de bien comprendre leur rôle, ça vaut le coup de l'exprimer explicitement : une unique lifetime est inutile, puisque leur raison d'être est de lier PLUSIEURS références. J'ajoute que les lifetimes sont les lifetimes d'une référence (la notion de lifetime est forcément adossée à une référence).

> To use lifetime annotations in function signatures, we need to declare the generic lifetime parameters inside angle brackets between the function name and the parameter list, just as we did with generic type parameters.

^ du point de vue syntaxe, ça ressemble aux generics : la fonction est "paramétrée" par la lifetime.

> We want the signature to express the following constraint: the returned reference will be valid as long as both the parameters are valid.

^ c'est la façon de lire la signature suivante :

```rs
# the returned reference will be valid as long as both the parameters are valid :
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str
```

NDM : les lifetimes lient la durée de vie de l'output aux durées de vie des inputs (ce qui est logique).

Autre point : veut on vraiment lier le retour aux DEUX entrées ? Ça n'est pas forcément vrai dans le cas général, mais ici oui, car au runtime, le retour pourra nécessiter d'être en vie aussi longtemps que le premier input OU que le second input : les deux cas peuvent se produire. Du coup, à l'analyse statique (faite par le borrow-checker), il faut vérifier que l'output reste bien en vie aussi longtemps que les DEUX inputs, et donc lier la lifetime de l'output aux DEUX lifetimes des inputs.

> The function signature now tells Rust that for some lifetime 'a, the function takes two parameters, both of which are string slices that live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime 'a.

^ c'est une formulation intéressante, où la lifetime est en quelque sorte une variable d'entrée de la fonction.

> In practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the values referred to by the function arguments.

^ c'est bien comme ça que se lit la signature de la fonction, et c'est ce point que va vérifier le borrow-checker, grâce à nos jolies annotations de lifetimes.

> Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints

^ dit autrement, les lifetimes ne sont que des indications à destination de l'analyseur statique = le borrow-checker, mais ne changent rien au comportement du code (un peu comme les annotations python sont des indications à destination de mypy, mais ne changent rien au comportement du code).

> When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. The lifetime annotations become part of the contract of the function, much like the types in the signature

Les lifetimes annotations font partie de la signature des fonctions.

> the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter 'a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.

^ du point de vue du borrow-checker lorsqu'il analyse la fonction, toutes les lifetimes (y compris celle de la variable de retour) ont comme durée de vie celle de la référence de plus petite durée de vie.

C'est illustré par l'exemple suivant, qui est REFUSÉ par le borrow-checker :

```rs
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

^ en effet, au moment de l'appel à `println!`, `result` a une durée de vie égale à la plus petite durée de vie des deux références en input, soit celle de `string2`, dans le inner scope. Du coup, `println!` utilise la référence vers `result` en dehors du scope où elle est en vie ! L'erreur de compilation est qu'il considère que `string2` est toujours borrowed (par `result`, je suppose) au moment où elle arrive en fin de vie (= elle est dropped) lorsqu'on quitte l'inner scope.

Un autre exemple pour montrer que les lifetimes servent à lier le cycle de vie de références, et qu'il est donc inutile de les lier si elles n'ont aucun lien réel :

```rs
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

> We’ve specified a lifetime parameter 'a for the parameter x and the return type, but not for the parameter y, because the lifetime of y does not have any relationship with the lifetime of x or the return value.

^ il n'est pertinent de lier la return value qu'à `x`, vu que `y` n'a pas de lien avec la valeur de retour.

Un troisième exemple est particulièrement intéressant, le snippet essaye de retourner une référence sur une valeur créée dans la fonction, ce qui ne marche évidemment pas (puisque le valeur est détruite aussitôt qu'on sort de la fonction, donc la référence retournée ne peut être que dangling, ce que le borrow-checker n'autorise pas). La solution dans ce cas (au moins pour cet exemple) est de plutôt renvoyer une owning value.

> Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.

^ excellent résumé !

Utilisation dans les structs :

```rs
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

> (...) This annotation means an instance of ImportantExcerpt can’t outlive the reference it holds in its part field.

^ similairement, on peut lier le cycle de vie d'une struct aux cycles de vie des références qui la constituent (pour faire le lien avec les exemples précédents qui étaient données avec une fonction, la struct est alors l'équivalent de l'output de la fonction, et les membres sont équivalentes aux inputs)



REPRENDRE À : Thinking in Terms of Lifetimes

## Appendix D - Useful Development Tools

https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html


----

REPRENDRE À : Chapitre 5.3 = Method Syntax

# When I do TDD and when I don’t

- **url** = https://www.codewithjason.com/when-i-do-tdd-and-when-i-dont/
- **type** = post
- **auteur** = [Jason SWETT](https://www.codewithjason.com/about/), dev Ruby et conférencier, qui semble avoir un focus sur le testing
- **date de publication** = 2022-02-14
- **source** = [code with jason, son blog](https://www.codewithjason.com/)
- **tags** = language>agnostic ; topic>tdd ; level>beginner


**TL;DR** : son post formalise une notion qui était implicite jusqu'ici pour moi : il existe deux raisons de coder = pour créer un produit, ou bien pour y voir plus clair.

Son résumé (un poil réordonné) me suffit à commenter son post :

> Producing a work product is not the only reason to write code. Code can also be a medium for thinking.

Parfois, on code pour formaliser des idées, et les challenger ; en deux mots "pour y voir plus clair".

> When I’m in the [mood] of using coding as a way to think, I find that the benefits of TDD don’t really apply.

Quand on code "pour y voir plus clair", TDD n'a pas d'intérêt.

> I don’t practice TDD 100% of the time. (I believe I do practice TDD the vast majority of the time though.)

Mais quand on code pour créer un produit (donc, le reste du temps, ce qui représente la majeure partie du temps), TDD conserve son intérêt !

> I view TDD as the automated version of the coding workflow that I already use anyway.

Dans [un autre post](https://www.codewithjason.com/program-feedback-loops/), il précise la façon dont il bosse = en utilisant une _feedback loop_ pour vérifier l'avancée de son travail ; les TDD ne sont qu'une automatisation de cette _feedback loop_.

---

Au passage, je découvre la notion SCRUM de [spike](https://www.qualitystreet.fr/2019/09/25/le-spike-en-scrum/) , qui est une formalisation SCRUM des stories d'étude qu'on pratique.
